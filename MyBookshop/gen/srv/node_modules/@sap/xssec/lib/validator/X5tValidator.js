const { X509Certificate, createHash } = require('node:crypto');

const debug = require('debug');
const debugTrace = debug('xssec:validators');
debugTrace.log = console.log.bind(console);
const debugError = debug('xssec:validators');
debugError.log = console.error.bind(console);

const { CNF_X5T_CLAIM, FWD_CLIENT_CERT_HEADER, PEM_HEADER, PEM_FOOTER } = require("../../lib/constants");
const ValidationResults = require("./ValidationResults");

/**
 * Validates the ownership of tokens based on certificate-binding described in {@link https://datatracker.ietf.org/doc/html/rfc8705 RFC 8705}.
 */
class X5tValidator {
    /**
     * Validates that the client owning the given certificate is the owner of the token.
     * The validation is based on proof-of-posession via certificate binding of tokens as described in {@link https://datatracker.ietf.org/doc/html/rfc8705 RFC 8705}.
     * The validation is succesful if the token contains an base64url-encoded x5t thumbprint under claim {@link CNF_X5T_CLAIM cnf.x5t#S256} that matches the given certificate.
     * The client certificate against which the validation is performed, is typically extracted from the {@link FWD_CLIENT_CERT_HEADER x-forwarded-client-cert} request header where it is put by BTP after TLS termination.
     * @param {*} token a decoded token
     * @param {*} cert DER or PEM certificate
     * @returns valid {@link ValidationResults} if the thumbprint in the token matches the given certificate, otherwise invalid ValidationResults with an error description.
     */
    static validateToken(token, cert) {
        if (!cert) {
            return ValidationResults.createInvalid("x5t validation failed because client certificate was missing or empty.");
        }

        debugTrace(`client certificate for x5t validation: ${cert}`);

        let tokenX5t;
        try {
            tokenX5t = token.getPayload()["cnf"][CNF_X5T_CLAIM];
            if(!tokenX5t) throw new Error();
        } catch (e) {
            return ValidationResults.createInvalid("x5t validation failed because x5t thumbprint could not be found in token.");
        }
        debugTrace(`x5t thumbprint inside token: ${tokenX5t}`)

        let x509Certificate;
        try {
            x509Certificate = X5tValidator.parseCertificate(cert);
        } catch (e) {
            debugError(e);
            return ValidationResults.createInvalid(`x5t validation failed because client certificate could not be parsed.}`);
        }

        let certificateX5t;
        try {
            certificateX5t = Buffer.from(x509Certificate.fingerprint256.replaceAll(":", ""), "hex").toString("base64url");
        } catch (e) {
            debugError(e);
            return ValidationResults.createInvalid("x5t validation failed because x5t thumbprint could not be calculated from client certificate.");
        }
        debugTrace(`x5t thumbprint of client certificate (base64url-encoded): ${certificateX5t}`)

        if (certificateX5t === tokenX5t) {
            return ValidationResults.createValid();
        } else {
            return ValidationResults.createInvalid("x5t thumbprint did not match the thumbprint of the provided client certificate.");
        }
    }

    /**
     * Parses the given certificate to a X509Certificate object.
     * @param {*} cert DER or PEM certificate
     * @returns certificate parsed as X509Certificate
     */
    static parseCertificate(cert) {       
        // add PEM header and footer
        if(!cert.startsWith(PEM_HEADER)) cert = `${PEM_HEADER}\n${cert}`;
        if(!cert.endsWith(PEM_FOOTER)) cert = `${cert}\n${PEM_FOOTER}`;

        return new X509Certificate(cert);
    }
}

module.exports = X5tValidator;