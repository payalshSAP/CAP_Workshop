#!/usr/bin/env node

// Very simple command-line interface for syntax highlighting CDS sources.  The
// interesting part is the correct classification of identifiers versus
// keywords, especially non-reserved ones.  Identifiers might even be
// classified further, especially where the identifier defines a new name.
//
// The output could be used directly by some editors, e.g. Emacs.

/* eslint no-console:off */

'use strict';

const compiler = require('../lib/compiler');
const fs = require('fs');
fs.readFile( '/dev/stdin', 'utf8', highlight );

const categoryChars = {         // default: first char of category name
  // first char lowercase = reference other than via extend/annotate:
  artref: 'm',
  uncheckedRef: 'r',
  uncheckedAnno: 'a',
  paramname: 'b',
  typeparamname: 'b',
  // first char uppercase = definition, extend/annotate ref, or path after `namespace`:
  Entity: 'D',
  Enum: 'H',
  Index: 'J',
  AnnoDef: 'V',
  Ext: 'Z',                 // extend/annotate on main def other than service/context
  ExtService: 'S',          // highlight like service definition
  ExtContext: 'C',          // highlight like context definition
  // ExtElement: 'E',       // using the first letter is the default
  ExtBoundAction: 'B',      // highlight like bound action definition
  ExtParam: 'P',            // highlight like entity/action parameter definition
  Event: 'Y',
  // Remark: do not use `x`/`X` (hex literal `x'1e3d'`)
};

function highlight( err, buf ) {
  if (err) {
    console.error( 'ERROR:', err.toString() );
    return;
  }
  const ts = compiler.parseX( buf, 'hi.cds', { attachTokens: true, messages: [] } ).tokenStream;
  if (!buf.length || !ts.tokens || !ts.tokens.length)
    return;
  const chars = [ ...buf ];
  for (const tok of ts.tokens) {
    if (tok.start < 0)
      continue;
    if (tok.$isSkipped) {
      if (tok.stop > tok.start) {
        chars[tok.start] = (tok.$isSkipped === true ? '\x0f' : '\x16'); // ^O / ^V
        chars[tok.stop] = '\x17';                                       // ^W
      }
      else {
        chars[tok.start] = (tok.$isSkipped === true ? '\x0e' : '\x15'); // ^N / ^U
      }
    }
    else {
      const cat = tok.isIdentifier;
      if (cat) {
        if (cat !== 'ref' || chars[tok.start] !== '$')
          chars[tok.start] = categoryChars[cat] || cat.charAt(0);
        if (tok.stop > tok.start) // stop in ANTLR at last char, not behind
          chars[tok.start + 1] = '_';
      }
    }
  }
  for (const c of chars)
    process.stdout.write( c );
}
