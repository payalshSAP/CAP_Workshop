function getNested(k, obj) {
  let cur = obj
  let p = ''
  const parts = k.split('_')
  while (parts.length) {
    const q = parts.shift()
    if (q in cur) {
      cur = cur[q]
      p = ''
    } else {
      p = p ? p + '_' + q : q
      if (p in cur) {
        cur = cur[p]
        p = ''
      } else {
        if (Object.keys(cur).some(k => k.startsWith(p + '_'))) {
          // continue for now as there's still a chance
        } else {
          // abort
          return undefined
        }
      }
    }
  }
  return cur[p] || cur !== obj ? cur : undefined
}

const getNormalizedDecimal = val => {
  let v = `${val}`
  const cgs = v.match(/^(\d*\.*\d*)e([+|-]*)(\d*)$/)
  if (cgs) {
    let [l, r = ''] = cgs[1].split('.')
    const dir = cgs[2] || '+'
    const exp = Number(cgs[3])
    if (dir === '+') {
      // move decimal point to the right
      r = r.padEnd(exp, '0')
      l += r.substring(0, exp)
      r = r.slice(exp)
      v = `${l}${r ? '.' + r : ''}`
    } else {
      // move decimal point to the left
      l = l.padStart(exp, '0')
      r = l.substring(0, exp) + r
      l = l.slice(exp)
      v = `${l ? l : '0'}.${r}`
    }
  }
  return v
}

function getTarget(path, k) {
  return path.length && path[path.length - 1].match(/\[\d+\]$/) ? path.join('/') : path.concat(k).join('/')
}

// non-strict mode also allows url-safe base64 strings
function isBase64String(string, strict = false) {
  if (typeof string !== 'string') return false

  if (strict && string.length % 4 !== 0) return false

  let length = string.length
  if (string.endsWith('==')) length -= 2
  else if (string.endsWith('=')) length -= 1

  let char
  for (let i = 0; i < length; i++) {
    char = string[i]
    if (char >= 'A' && char <= 'Z') continue
    else if (char >= 'a' && char <= 'z') continue
    else if (char >= '0' && char <= '9') continue
    else if (char === '+' || char === '/') continue
    else if (!strict && (char === '-' || char === '_')) continue
    return false
  }

  return true
}

const resolveCDSType = ele => {
  // REVISIT: when is ele._type not set and sufficient?
  if (ele._type?.match(/^cds\./)) return ele._type
  if (ele.type) {
    if (ele.type.match(/^cds\./)) return ele.type
    return resolveCDSType(ele.__proto__)
  }
  if (ele.items) return resolveCDSType(ele.items)
  return ele
}

function resolveSegment(prev, obj, def) {
  if (prev.keys) {
    let keys = []
    for (const k of prev.keys) {
      let val
      if (k in obj) val = obj[k]
      else val = getNested(k, obj)
      if (val == null) {
        // in some cases, k is not given, e.g., POST into collection via navigation
        // TODO: what to put in target? "null", "transient", ...?
        if (k === 'IsActiveEntity')
          keys.push(`${k}=false`) //> always false if not in obj as it must be a draft activate
        else keys.push(`${k}=null`)
      } else {
        const type = resolveCDSType(def.elements[k])
        if (type === 'cds.String') val = `'${val}'`
        // TODO: more proper val encoding based on type
        keys.push(`${k}=${val}`)
      }
    }
    return `${prev.assoc}(${keys.join(',')})`
  }
  if (prev.index) {
    return `${prev.prop}[${prev.index}]`
  }
}

module.exports = {
  getNested,
  getNormalizedDecimal,
  getTarget,
  isBase64String,
  resolveCDSType,
  resolveSegment
}
