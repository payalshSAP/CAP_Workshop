const { cds } = global

const typeCheckers = require('./type')
const { checkMandatory, checkEnum, checkRange, checkFormat } = require('./validation')
const { getNested, getNormalizedDecimal, getTarget, resolveCDSType, resolveSegment } = require('./utils')

const NUMBER_TYPES = new Set(['cds.UInt8', 'cds.Int16', 'cds.Int32', 'cds.Integer', 'cds.Double'])

const _no_op = () => {}

const _reject_unknown = (_, k, def, errs) =>
  errs.push(new cds.error(`Property "${k}" does not exist in ${def.name}`, { statusCode: 400, code: '400' }))

const _filter_unknown = (obj, k) => delete obj[k]

const _handle_mandatories = (obj, def, errs, path) => {
  for (const [k, ele] of def._mandatories) {
    const v = obj[k] === undefined ? getNested(k, obj) : obj[k]
    checkMandatory(v, ele, errs, path, k)
  }
}

const _handle_mandatories_if_insert = (obj, def, errs, path) => {
  if (!def.keys) return _handle_mandatories(obj, def, errs, path)
  const allKeysProvided = Object.keys(def.keys).every(k => k in obj)
  for (const [k, ele] of def._mandatories) {
    const v = obj[k] === undefined ? getNested(k, obj) : obj[k]
    if (!allKeysProvided || v !== undefined) checkMandatory(v, ele, errs, path, k)
  }
}

function _recurse(obj, prefix, def, errs, opts) {
  for (const [k, v] of Object.entries(obj)) {
    if (v != null && typeof v === 'object' && !Array.isArray(v)) {
      _recurse(v, prefix + k + '_', def, errs, opts)
      continue
    }
    const flat = { [prefix + k]: v }
    _process(flat, def, errs, opts)
    if (!Object.keys(flat).length) delete obj[k] //> filtered out inside _process -> propagate to original object
  }
}

function _process(obj, def, errs, opts) {
  if (obj == null) return

  if (Array.isArray(obj)) {
    for (const row of obj) _process(row, def, errs, opts)
    return
  }

  // TODO: path should be cqn
  const prev = opts.path.length && opts.path[opts.path.length - 1]
  if (prev?.keys || prev?.index) opts.path[opts.path.length - 1] = resolveSegment(prev, obj, def)

  if (def._mandatories?.length) opts._handle_mandatories(obj, def, errs, opts.path)

  for (let [k, v] of Object.entries(obj)) {
    let ele = def.elements?.[k] || def.params?.[k] || def.items
    if (typeof ele !== 'object') ele = undefined //> ignore non-object elements, e.g., functions of prototypes

    /*
     * TODO: should we support this? with or without transformation?
     * structured vs flat
     *   the combination of the two cases below SHOULD cover mixed cases like
     *   foo: { bar: { baz: { ... } } } and foo_bar: { baz: { ... } }
     *   TODO: add tests!!!
     */
    // case 1: structured data but flat model
    if (
      !ele &&
      typeof obj[k] === 'object' &&
      !Array.isArray(obj[k]) &&
      (def.elements || def.params) &&
      Object.keys(def.elements || def.params).find(key => key.startsWith(`${k}_`))
    ) {
      _recurse(obj[k], k + '_', def, errs, opts)
      continue
    }
    // case 2: flat data but structured model
    if (!ele && k.split('_').length > 1) {
      // TODO: handle stuff like foo__bar, i.e., foo_: { bar: ... }
      const parts = k.split('_')
      let cur = def.elements || def.params
      while (cur && parts.length) cur = (cur.elements || cur.params)?.[parts.shift()]
      if (cur) ele = cur
    }

    if (!ele) {
      if (!def['@open']) opts._handle_unknown(obj, k, def, errs)
      continue
    }

    if (ele.isAssociation) {
      const keys = ele.keys?.map(k => k.ref[0]) || Object.keys(ele._target.keys)
      opts.path.push(ele.is2many || Object.keys(keys).length ? { assoc: k, keys } : k)
      // NOTE: the assumption is that children with all keys provided are not inserted, but updated
      // -> incomplete but best we can do without roundtrip
      _process(v, ele._target, errs, {
        ...opts,
        _handle_mandatories:
          opts.mandatories === false || ele._isAssociationStrict
            ? _no_op
            : opts.mandatories === true
              ? _handle_mandatories
              : _handle_mandatories_if_insert
      })
      opts.path.pop()
      continue
    }
    if (ele._isStructured) {
      opts.path.push(k)
      _process(v, ele, errs, opts)
      opts.path.pop()
      continue
    }
    if (ele instanceof cds.builtin.classes.array) {
      for (let i = 0; i < v.length; i++) {
        opts.path.push({ prop: k, index: i })
        const _def = ele.items?.__proto__.elements ? ele.items.__proto__ : ele.__proto__
        const _obj = _def.elements ? v[i] : { [k]: v[i] }
        _process(_obj, _def, errs, opts)
        opts.path.pop()
      }
      continue
    }

    if (ele.notNull && v === null) {
      const target = getTarget(opts.path, k)
      errs.push(new cds.error('ASSERT_NOT_NULL', { target, statusCode: 400, code: '400' }))
      continue
    }

    const type = resolveCDSType(ele)
    if (type?.match(/^cds\.hana\./)) continue

    let typeChecker = typeCheckers[type]
    if (typeChecker) {
      if (v == null) continue

      // if used in protocol adapter, adjust val/ checker if necessary
      if (opts.http) {
        if (typeof v !== 'boolean') {
          if (type === 'cds.Decimal') v = getNormalizedDecimal(v)
          else if (type === 'cds.Int64') v = String(v)
          else if (NUMBER_TYPES.has(type)) v = Number(v)
        }
      }

      // use relaxed uuid check if not in strict mode
      if (type === 'cds.UUID' && !opts.strict) typeChecker = typeCheckers['relaxed.UUID']

      // type check
      // REVISIT: all checkers should add errors themselves!
      if (type === 'cds.Decimal')
        typeChecker(v, ele, errs, opts.path, k) //> _checkDecimal adds error itself
      else if (!typeChecker(v, ele) || (opts.strict && typeChecker.name === '_checkBuffer' && typeof v === 'string')) {
        errs.push(
          new cds.error('ASSERT_DATA_TYPE', {
            args: [typeof obj[k] === 'string' ? `"${obj[k]}"` : obj[k], ele._type],
            target: getTarget(opts.path, k),
            statusCode: 400,
            code: '400'
          })
        )
      }

      // propagate correction if necessary
      if (obj[k] !== v) obj[k] = v

      // @assert
      if (ele['@assert.enum'] || (ele['@assert.range'] && ele.enum)) checkEnum(v, ele, errs, opts.path, k)
      if (ele['@assert.range']) checkRange(v, ele, errs, opts.path, k)
      if (ele['@assert.format']) checkFormat(v, ele, errs, opts.path, k)
      // REVISIT: @assert.target? -> no because async, but maybe return the necessary query to execute?

      continue
    }

    throw new Error(`Missing type check for "${ele.type}" (property "${k}" of "${def.name}")`)
  }
}

/**
 * Asserts the given data against the given CSN definition and returns an array of errors or undefined.
 *
 * @param {object} data - the data to be checked
 * @param {LinkedCSN} definition - the CSN definition to which the data should be checked against
 * @param {object} [options] - options
 * @param {boolean} [options.strict] - if true, an error is thrown if a property is not defined in the CSN
 * @param {boolean} [options.filter] - if true, properties not defined in the CSN are filtered out
 * @param {boolean} [options.mandatories] - if false, mandatory properties are never checked.
 *   if true, mandatory properties are always checked.
 *   if undefined, mandatory properties are checked for presumed insert rows only (determined by a heuristic to avoid roundtrip).
 * @param {object} [options.http] - the HTTP request object providing access to headers, etc.
 * @param {*[]} [options.path] - collector for the current path, should not be set manually
 * @return {Array} - an array of errors or undefined if no errors
 */
module.exports = (data, definition, options = {}) => {
  if (!data) throw new Error('Argument "data" was not provided')
  if (typeof data !== 'object') throw new Error('Argument "data" must be an object (or an array)')

  if (!definition) throw new Error('Argument "entity" was not provided')
  // FIXME: definition instanceof cds.builtin.classes.any doesn't always work for some reason
  if (!(definition instanceof cds.builtin.classes.any) && !(definition.kind in { entity: 1, action: 1, function: 1 })) {
    throw new Error('Argument "definition" is not a valid CSN element')
  }

  // TODO: feature flags instead of process env vars
  options.strict ??= process.env.CDS_ASSERT_STRICT === 'true'
  options.filter ??= process.env.CDS_ASSERT_FILTER === 'true'
  options.path ??= []

  // materialize what is done ...
  // ... in case of unknown elements
  if (options.strict) options._handle_unknown = _reject_unknown
  else if (options.filter) options._handle_unknown = _filter_unknown
  else options._handle_unknown = _no_op
  // ... regarding mandatory elements
  if (options.mandatories === false) options._handle_mandatories = _no_op
  else if (options.mandatories === true) options._handle_mandatories = _handle_mandatories
  else options._handle_mandatories = _handle_mandatories_if_insert

  const errs = []
  _process(data, definition, errs, options)
  return errs.length ? errs : undefined
}
