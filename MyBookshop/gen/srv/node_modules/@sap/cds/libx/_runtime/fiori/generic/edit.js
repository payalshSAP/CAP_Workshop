const cds = require('../../cds')
const getLockInfo = require('../utils/lockInfo')
const { INSERT, SELECT, DELETE } = cds.ql

const { getCompositionTree } = require('../../common/composition')
const { getColumns } = require('../../common/utils/columns')
const { draftIsLocked, ensureDraftsSuffix, ensureNoDraftsSuffix, getSubCQNs } = require('../utils/handler')
const { isActiveEntityRequested } = require('../utils/where')

const _getDraftColumns = draftUUID => ({
  IsActiveEntity: false,
  HasDraftEntity: false,
  HasActiveEntity: true,
  DraftAdministrativeData_DraftUUID: draftUUID
})

const _getAdminData = ({ user }, draftUUID, time) => {
  const currentUser = user.id || null
  return {
    DraftUUID: draftUUID,
    CreationDateTime: time,
    CreatedByUser: currentUser,
    LastChangeDateTime: time,
    LastChangedByUser: currentUser,
    DraftIsCreatedByMe: true,
    DraftIsProcessedByMe: true,
    InProcessByUser: currentUser
  }
}

const _getInsertAdminDataCQN = ({ user }, draftUUID, time) => {
  return INSERT.into('DRAFT.DraftAdministrativeData').entries(_getAdminData({ user }, draftUUID, time))
}

async function _lockAndSelectActive(req, lockRecordCQN, selectCQNs, draftExistsCQN) {
  try {
    await this.run(lockRecordCQN)
  } catch (e) {
    const drafts = await this.run(draftExistsCQN)
    if (drafts.length) req.reject(409, 'DRAFT_ALREADY_EXISTS')
    req.reject(409, 'ENTITY_LOCKED')
  }

  const cqns = [this.run(draftExistsCQN), ...selectCQNs.map(cqn => this.run(cqn))]
  const promisesResults = await Promise.allSettled(cqns)
  const firstRejected = promisesResults.find(r => r.status === 'rejected')
  if (firstRejected) req.reject(firstRejected.reason)
  return promisesResults.map(result => result.value)
}

/**
 * Generic event handler for draft edit requests.
 *
 * @param req
 */
const fioriGenericEdit = async function (req, next) {
  if (!req.target._isDraftEnabled) return next()

  if (!isActiveEntityRequested(req.query.SELECT.where || [])) {
    req.reject(400, 'Action "draftEdit" can only be called on the active entity')
  }

  if (!cds.db) req.reject('NO_DATABASE_CONNECTION')

  const { definitions } = this.model
  const lockInfo = getLockInfo(req)
  const rootWhere = lockInfo.rootWhere

  // Ensure exclusive access to the root record of the active entity by applying a lock,
  // which effectively prevents the creation or overwriting of duplicate draft entities.
  // This lock mechanism enforces a strict processing order for active entities,
  // allowing only one entity to be worked on at any given time.
  // By using .forUpdate() with a wait value of 0, we immediately lock the record,
  // ensuring there is no waiting time for other users attempting to edit the same record concurrently.
  const activeLockCQN = SELECT.from(lockInfo.target, [1]).where(lockInfo.where).forUpdate({ wait: 0 })

  const columnNames = getColumns(req.target, { onlyNames: true, filterVirtual: true })
  const rootCQN = SELECT.from(req.target, columnNames).where(rootWhere)
  const subCQNs = getSubCQNs({
    definitions,
    rootCQN,
    compositionTree: getCompositionTree({ definitions, rootEntityName: ensureNoDraftsSuffix(req.target.name) })
  })
  const rootDraftName = ensureDraftsSuffix(req.target.name)
  const draftExistsCQN = SELECT.from(rootDraftName, ['DraftAdministrativeData_DraftUUID as DraftUUID']).where(rootWhere)
  const selectCQNs = [rootCQN, ...subCQNs.map(obj => obj.cqn)]

  // fetch unlocalized data if not a texts entity
  for (const q of selectCQNs) {
    const entity = definitions[q.SELECT.from.ref[0]]
    if (entity && !entity.name.match(/\.texts$/)) {
      q.SELECT.localized = false
    }
  }

  const dbtx = cds.tx(req)
  // REVISIT: Use service.read with expand **
  const [draftExists, ...results] = await _lockAndSelectActive.call(
    dbtx,
    req,
    activeLockCQN,
    [...selectCQNs],
    draftExistsCQN
  )

  if (!results[0].length) req.reject(404)

  if (draftExists.length) {
    const adminData = await dbtx.run(
      SELECT.one('DRAFT.DraftAdministrativeData', ['InProcessByUser', 'LastChangeDateTime']).where(draftExists[0])
    )

    // temp check if draft admin data in not maintained - raise 500 error
    if (!adminData) req.reject(500, 'Draft administrative data is not maintained')

    // draft is locked (default cancellation timeout timer has not expired) OR
    // draft is not locked but must be rejected for popup
    if (draftIsLocked(adminData.LastChangeDateTime) || req.data.PreserveChanges) {
      req.reject(409, 'DRAFT_ALREADY_EXISTS')
    }

    await Promise.all([
      dbtx.run(DELETE.from('DRAFT.DraftAdministrativeData').where(draftExists[0])),
      dbtx.run(DELETE.from(rootDraftName).where(rootWhere))
    ])
  }

  const draftUUID = cds.utils.uuid()
  const insertCQNs = [_getInsertAdminDataCQN(req, draftUUID, req.timestamp)]

  for (const resultIndex in results) {
    if (results[resultIndex].length === 0) continue
    const draftEntity = ensureDraftsSuffix(selectCQNs[resultIndex].SELECT.from.ref[0])
    const entries = results[resultIndex].map(entityResult =>
      Object.assign({}, entityResult, _getDraftColumns(draftUUID))
    )

    insertCQNs.push(INSERT.into(draftEntity).entries(entries))
  }

  await Promise.all(insertCQNs.map(CQN => dbtx.run(CQN)))

  // REVISIT: we need to use okra API here because it must be set in the batched request
  //          status code must be set in handler to allow overriding for FE V2
  // REVISIT: needs reworking for new adapter, especially re $batch
  if (req._?.odataRes) {
    req._?.odataRes?.setStatusCode(201, { overwrite: true })
  } else if (req.http?.res) {
    req.http.res.status(201)
  }

  return results[0][0]
}

module.exports = cds.service.impl(function (srv) {
  srv.on('EDIT', '*', fioriGenericEdit)
})
