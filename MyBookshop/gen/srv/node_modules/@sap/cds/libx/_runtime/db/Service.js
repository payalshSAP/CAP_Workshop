const cds = require('../cds')
const { SELECT } = cds.ql
const { Transform } = require('stream')

/*
 * generic queries
 */
const queries = require('./query')

/*
 * generic handlers
 */
const generic = require('./generic')

// not able to pass in stream method into cds.utils.deprecated for unknown reason
// workaround: extract and deprecate helper function
const _streamDeprecation = () => {}

class DatabaseService extends cds.Service {
  constructor(...args) {
    super(...args)

    // REVISIT: official db api
    this._queries = queries

    // REVISIT: official db api
    for (const each in generic) {
      this[`_${each}`] = generic[each]
    }

    // REVISIT: how to generic handler registration?
  }

  /** Database services don't support custom-defined operations */
  get operations() {
    return []
  }

  /** Database services don't support custom-defined events */
  get events() {
    return []
  }

  /*
   * tx
   */
  async begin() {
    const tx = this.context ? this : this.tx()
    tx.dbc = await tx.acquire(tx.context)
    try {
      await tx.send('BEGIN')
    } catch (e) {
      tx.release(tx.dbc)
      throw e
    }
    return tx
  }

  async commit() {
    // only release on successful commit as otherwise released on rollback
    await this.send('COMMIT')
    this.release(this.dbc)
  }

  async rollback() {
    if (this.dbc) {
      try {
        await this.send('ROLLBACK')
      } finally {
        this.release(this.dbc)
      }
    }
  }

  /*
   * streaming
   */
  _runStream(streamQuery, result) {
    this.run(streamQuery).then(stream => {
      if (cds.env.features.stream_compat) {
        if (!stream || !stream.value) {
          result.push(null)
        } else {
          stream.value.pipe(result)
        }
      } else {
        const col = streamQuery.SELECT.columns[0].ref[0]
        if (!stream || !stream[col]) {
          result.push(null)
        } else {
          stream[col].pipe(result)
        }
      }
    })
  }

  stream(query) {
    cds.utils.deprecated(_streamDeprecation, { old: 'cds.stream' })()
    // aynchronous API: cds.stream(query)
    if (typeof query === 'object') {
      // eslint-disable-next-line no-async-promise-executor
      return new Promise(async (resolve, reject) => {
        try {
          if (cds.env.features.stream_compat) {
            const res = await this.run(Object.assign(query, { _streaming: true }))
            resolve(res && res.value)
          } else {
            const res = await this.run(query)
            // rely on query returning correct column (as documented for srv.stream(query))
            if (Array.isArray(res)) {
              resolve(res.length ? Object.values(res[0])[0] : undefined)
            } else {
              resolve(res && Object.values(res)[0])
            }
          }
        } catch (e) {
          reject(e)
        }
      })
    }

    // synchronous API: cds.stream('column').from(entity).where(...)
    return {
      from: (...args) => {
        const streamQuery = SELECT.one.from(...args)
        if (query && (!streamQuery.SELECT.columns || streamQuery.SELECT.columns.length !== 0)) {
          streamQuery.columns([query])
        }

        if (cds.env.features.stream_compat) streamQuery._streaming = true

        const result = new Transform({
          transform(chunk, encoding, callback) {
            this.push(chunk)
            callback()
          }
        })

        if (
          !streamQuery.SELECT.where &&
          !(
            streamQuery.SELECT.from &&
            streamQuery.SELECT.from.ref &&
            streamQuery.SELECT.from.ref[streamQuery.SELECT.from.ref.length - 1].where
          )
        ) {
          return {
            where: (...args) => {
              streamQuery.where(...args)
              this._runStream(streamQuery, result)
              return result
            }
          }
        }

        this._runStream(streamQuery, result)

        return result
      }
    }
  }
}

DatabaseService.prototype.isDatabaseService = true
module.exports = DatabaseService
