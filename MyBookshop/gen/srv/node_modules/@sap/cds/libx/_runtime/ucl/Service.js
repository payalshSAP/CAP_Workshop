const cds = require('../cds')
const LOG = cds.log('ucl')

const https = require('https')

class UCLService extends cds.Service {
  async init() {
    await super.init()
    this.validate()
    this._register()
    this.agent = this.getAgent()
  }

  getAgent() {
    try {
      if (this.options.x509.certPath && this.options.x509.pkeyPath) {
        return new https.Agent({
          cert: cds.utils.fs.readFileSync(cds.utils.path.resolve(cds.root, this.options.x509.certPath)),
          key: cds.utils.fs.readFileSync(cds.utils.path.resolve(cds.root, this.options.x509.pkeyPath))
        })
      }
    } catch (error) {
      if (LOG) LOG.error('GetCredentials', { error: error.message })
      throw error
    }
  }

  async _registerProvisioningEvents() {
    var provisioning
    try {
      provisioning = await cds.connect.to('cds.xt.SaasProvisioningService')
    } catch (error) {
      throw new Error(
        "Provisioning service 'cds.xt.SaasProvisioningService' can not be found, therefore mode is not multitenant. Single tenant applications are not supported."
      )
    }
    if (provisioning) {
      provisioning.prepend(() => {
        provisioning.on('dependencies', async (_, next) => {
          let dependencies = await next()
          const xsappnameCMPClone = await this._getUCLDependency()
          dependencies.push({ xsappname: xsappnameCMPClone })
          return dependencies
        })
      })
    }
  }

  validate() {
    if (!this.options.namespace) {
      throw new Error(
        'UCL integrator requires an application namespace. You can set environment variable SAP_APPLICATION_NAMESPACE or you can give namespace as an option in your cds.requires section as described in documentation'
      )
    }
    if (!cds.requires.multitenancy && cds.env.profile !== 'mtx-sidecar') {
      throw new Error('[ucl] - Currently only multitenant applications are supported.')
    }
    if (!this.options.systemType || !this.options.systemDescription) {
      throw new Error(
        'systemType and systemDescription is obligatory parameters, please fill as shown in documentation'
      )
    }
  }

  async readTemplate() {
    const xsappname = this.options.credentials.xsappname
    const query = `
      query ($key: String!, $value: String!) {
        applicationTemplates(filter: { key: $key, query: $value }) {
          data {
            id
            name
            description
            placeholders {
              name
              description
            }
            applicationInput
            labels
            webhooks {
              type
            }
          }
        }
      }
    `
    const variables = { key: 'xsappname', value: `"${xsappname}"` }
    return (await this.request(query, variables)).applicationTemplates.data[0]
  }

  async _createTemplate() {
    const xsappname = this.options.credentials.xsappname
    const query = `mutation {
          result: createApplicationTemplate (
              in: {
              name: "${this.options.systemType}"
              description: "${this.options.systemDescription}"
              applicationInput: {
                  name: "${this.options.systemType}" 
                  description: "${this.options.systemDescription}"
                  providerName: "${this.options.provider}" 
                  localTenantID: "{{tenant-id}}"
                  labels: {
                  displayName: "{{subdomain}}"
                  }
              }
              placeholders: [
                  { name: "subdomain", description: "The subdomain of the consumer tenant" }
                  { name: "tenant-id", description: "The tenant id as it's known in the product's domain", jsonPath: "$.subscribedSubaccountId" }
              ]
              labels: {
                  managed_app_provisioning: true
                  xsappname: "${xsappname}"
              }
              applicationNamespace: "${this.options.namespace}"
              accessLevel: GLOBAL
              }
          ) {
              id
              name
              labels
              applicationInput 
              applicationNamespace
          }
      }`
    try {
      return this.handleResponse(await this.request(query))
    } catch (e) {
      this.handleResponse(e)
    }
  }

  handleResponse(result) {
    if (result.response && result.response.errors) {
      let errorMessage = result.response.errors[0].message
      throw new Error(errorMessage)
    } else {
      return result.result
    }
  }

  async deleteTemplate() {
    const template = await this.readTemplate()
    if (!template) return
    const query = `mutation {
            result: deleteApplicationTemplate(
              id: "${template.id}"
            ){
                id
                name
                description
            }
        }`
    return this.handleResponse(await this.request(query))
  }

  async _getUCLDependency() {
    if (!this.template) {
      throw Error('Application template not found on UCL!')
    }
    return this.template.labels.xsappnameCMPClone
  }

  // Replace with fetch
  async request(query, variables) {
    const opts = {
      host: this.options.host,
      path: this.options.path,
      agent: this.agent,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    }
    return new Promise((resolve, reject) => {
      const req = https.request(opts, res => {
        const chunks = []

        res.on('data', chunk => {
          chunks.push(chunk)
        })

        res.on('end', () => {
          const response = {
            statusCode: res.statusCode,
            headers: res.headers,
            body: Buffer.concat(chunks).toString()
          }
          resolve(JSON.parse(response.body).data)
        })
      })

      req.on('error', error => {
        reject(error)
      })

      if (query) {
        req.write(JSON.stringify({ query, variables }))
      }
      req.end()
    })
  }

  async _registerApplicationTemplate() {
    this.template = await this.readTemplate()
    if (!this.template) {
      LOG.info('Application Template cannot be found therefore created.')
      await this._createTemplate()
    } else {
      await this._updateTemplate(this.template)
    }
  }

  async _updateTemplate(template) {
    const query = `mutation {
    result: updateApplicationTemplate(
      id: "${template.id}"
      in: {
        name: "${this.options.systemType}"
        description: "${this.options.systemDescription}"
        applicationInput: {
          name: "${this.options.systemType}"
          description: "${this.options.systemDescription}"
          providerName: "${this.options.provider}" 
          localTenantID: "{{tenant-id}}"
          labels: { displayName: "{{subdomain}}" }
        }
        applicationNamespace: "${this.options.namespace}"
        placeholders: [
            { name: "subdomain", description: "The subdomain of the consumer tenant" }
            { name: "tenant-id", description: "The tenant id as it's known in the product's domain", jsonPath: "$.subscribedSubaccountId" }
        ]
        accessLevel: GLOBAL
      }
    ) {
      id
      name
      description
      applicationInput
    }
  }`
    try {
      const response = this.handleResponse(await this.request(query))
      LOG.info('Application template updated successfully.')
      return response
    } catch (e) {
      this.handleResponse(e)
    }
  }

  _register() {
    cds.once('listening', async () => {
      await this._registerApplicationTemplate()
      this._registerProvisioningEvents()
    })
  }
}

module.exports = UCLService
