const cds = require('../cds')

// eslint-disable-next-line cds/no-missing-dependencies -- needs to be added by app dev
const express = require('express')
const https = require('https')
const crypto = require('crypto')

async function request(options, data) {
  return new Promise((resolve, reject) => {
    const req = https.request(options, res => {
      const chunks = []
      res.on('data', chunk => {
        chunks.push(chunk)
      })
      res.on('end', () => {
        const response = {
          statusCode: res.statusCode,
          headers: res.headers,
          body: Buffer.concat(chunks).toString()
        }
        if (res.statusCode > 299) {
          reject({ message: response.body })
        } else {
          resolve(response)
        }
      })
    })
    req.on('error', error => {
      reject(error)
    })
    if (data) {
      req.write(JSON.stringify(data))
    }
    req.end()
  })
}

function _validateCertificate(req, res, next) {
  this.LOG.debug('event broker trying to authenticate via mTLS')

  if (req.headers['x-ssl-client-verify'] !== '0') {
    this.LOG.info('cf did not validate client certificate.')
    return res.status(401).json({ message: 'Authentication Failed' })
  }

  if (!req.headers['x-forwarded-client-cert']) {
    this.LOG.info('no certificate in xfcc header.')
    return res.status(401).json({ message: 'Authentication Failed' })
  }

  const bindingCert = new crypto.X509Certificate(this.options.credentials.certificate).toLegacyObject()
  const clientCert = new crypto.X509Certificate(
    `-----BEGIN CERTIFICATE-----\n${req.headers['x-forwarded-client-cert']}\n-----END CERTIFICATE-----`
  ).toLegacyObject()

  const cfSubject = Buffer.from(req.headers['x-ssl-client-subject-cn'], 'base64').toString()
  if (bindingCert.subject.CN !== clientCert.subject.CN || bindingCert.subject.CN !== cfSubject) {
    this.LOG.info('certificate subject does not match')
    return res.status(401).json({ message: 'Authentication Failed' })
  }
  this.LOG.debug('incoming Subject CN is valid.')

  if (bindingCert.issuer.CN !== clientCert.issuer.CN) {
    this.LOG.info('Certificate issuer subject does not match')
    return res.status(401).json({ message: 'Authentication Failed' })
  }
  this.LOG.debug('incoming issuer subject CN is valid.')

  if (bindingCert.issuer.O !== clientCert.issuer.O) {
    this.LOG.info('Certificate issuer org does not match')
    return res.status(401).json({ message: 'Authentication Failed' })
  }
  this.LOG.debug('incoming Issuer Org is valid.')

  if (bindingCert.issuer.OU !== clientCert.issuer.OU) {
    this.LOG.info('certificate issuer OU does not match')
    return res.status(401).json({ message: 'Authentication Failed' })
  }
  this.LOG.debug('certificate issuer OU is valid.')

  const valid_from = new Date(clientCert.valid_from)
  const valid_to = new Date(clientCert.valid_to)
  const now = new Date(Date.now())
  if (valid_from <= now && valid_to >= now) {
    this.LOG.debug('certificate validation completed')
    next()
  } else {
    this.LOG.error('Certificate expired')
    return res.status(401).json({ message: 'Authentication Failed' })
  }
}

// TODO: seems unused
function _checkAppDomains() {
  const pattern = /.*\.cert\.cfapps\..*\.hana\.ondemand\.com/
  const uris = JSON.parse(process.env.VCAP_APPLICATION).application_uris
  const matchFound = uris.some(uri => pattern.test(uri))
  if (matchFound)
    this.LOG.warn(
      `*.cert.cfapps.*.hana.ondemand.com domain is in use, this is not recommended in production! Please use 'mesh.cf.<region>.hana.ondemand.com' instead!`
    )
}

let instantiated = false

class EventBroker extends cds.MessagingService {
  async init() {
    // TODO: Only needed if there are subscriptions
    if (instantiated)
      throw new Error('Event Broker service must be a singleton service, you cannot have more than one instance.')
    instantiated = true
    await super.init()
    cds.once('listening', () => {
      this.startListening()
    })
    this.agent = this.getAgent()
  }

  getAgent() {
    try {
      if (this.options.x509.certPath && this.options.x509.pkeyPath) {
        return new https.Agent({
          cert: cds.utils.fs.readFileSync(cds.utils.path.resolve(cds.root, this.options.x509.certPath)),
          key: cds.utils.fs.readFileSync(cds.utils.path.resolve(cds.root, this.options.x509.pkeyPath))
        })
      }
    } catch (error) {
      if (this.LOG) this.LOG.error('GetCredentials', { error: error.message })
      throw error
    }
  }

  async handle(msg) {
    if (msg.inbound) return super.handle(msg)
    const _msg = this.message4(msg)
    await this.emitToEventBroker(_msg)
  }

  async startListening() {
    if (!this._listenToAll.value && !this.subscribedTopics.size) return
    await this.registerWebhookEndpoints()
  }

  async emitToEventBroker(msg) {
    // TODO: CSN definition probably not needed, just in case...
    //   See if there's a CSN entry for that event
    //   const found = cds?.model.definitions[topicOrEvent]
    //   if (found) return found  // case for fully-qualified event name
    //   for (const def in cds.model?.definitions) {
    //     const definition = cds.model.definitions[def]
    //     if (definition['@topic'] === topicOrEvent) return definition
    //   }

    // TODO: What if we're in single tenant variant?
    try {
      const ceSource = `${this.options.credentials.ceSource[0]}/${cds.context.tenant}`
      const hostname = this.options.credentials.eventing.http.x509.url.replace(/^https?:\/\//, '')
      // TODO Cloud Events Handler CAP
      const options = {
        hostname: hostname,
        method: 'POST',
        headers: {
          'ce-id': cds.utils.uuid(),
          'ce-source': ceSource,
          'ce-type': msg.event,
          'ce-specversion': '1.0',
          'Content-Type': 'application/json'
        },
        agent: this.agent
      }
      this.LOG.debug('HTTP headers:', JSON.stringify(options.headers))
      this.LOG.debug('HTTP body:', JSON.stringify(msg.data))
      await request(options, msg.data) // TODO: fetch does not work with mTLS as of today, requires another module. see https://github.com/nodejs/node/issues/48977
      if (this.LOG._info) this.LOG.info('Emit', { topic: msg.event })
    } catch (e) {
      this.LOG.error('Emit failed:', e.message)
    }
  }

  async registerWebhookEndpoints() {
    const webhookBasePath = this.options.webhookPath || '/-/cds/event-broker/webhook'
    cds.app.post(webhookBasePath, _validateCertificate.bind(this))
    cds.app.post(webhookBasePath, express.json())
    cds.app.post(webhookBasePath, this.onEventReceived.bind(this))
  }

  async onEventReceived(req, res) {
    try {
      const event = req.headers['ce-type'] // TG27: type contains namespace, so there's no collision
      const tenant = req.headers['ce-sapconsumertenant']
      const msg = {
        inbound: true,
        event,
        tenant,
        data: req.body ? req.body : undefined,
        headers: req.headers
      }
      const context = { user: cds.User.privileged }
      if (tenant) context.tenant = tenant // TODO: In single tenant case, we don't need a tenant
      await this.tx(context, tx => tx.emit(msg))
      this.LOG.debug('Event processed successfully.')
      return res.status(200).json({ message: 'OK' })
    } catch (e) {
      this.LOG.error('ERROR during inbound event processing:', e) // TODO: How does Event Broker do error handling?
      res.status(500).json({ message: 'Internal Server Error!' })
      throw e
    }
  }
}

module.exports = EventBroker
