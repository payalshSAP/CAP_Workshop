const cds = require('../_runtime/cds')

// eslint-disable-next-line cds/no-missing-dependencies -- needs to be added by app dev
const express = require('express')

const parse_factory = require('./middleware/parse')

const create_factory = require('./middleware/create')
const read_factory = require('./middleware/read')
const update_factory = require('./middleware/update')
const delete_factory = require('./middleware/delete')
const operation_factory = require('./middleware/operation')

const error_factory = require('./middleware/error')

const { bufferToBase64 } = require('../_runtime/common/utils/binary')
const { getAccessRestrictions } = require('../_runtime/common/utils/restrictions')

const RestAdapter = function (srv) {
  const router = express.Router()

  // -----------------------------------------------------------------------------------------
  // check @requires as soon as possible (DoS)
  //
  const accessRestrictions = getAccessRestrictions(srv)
  router.use((req, res, next) => {
    // ensure there always is a user going forward (not always the case with old or custom auth)
    if (!req.user) req.user = new cds.User.default()

    // check @restrict and @requires as soon as possible (DoS)
    if (!accessRestrictions.some(r => req.user.is(r))) {
      // > unauthorized or forbidden?
      if (req.user._is_anonymous) {
        // NOTE: "return req._login()" would not invoke custom error handlers
        if (req._login) res.set('www-authenticate', `Basic realm="Users"`)
        else if (req.user._challenges) res.set('www-authenticate', req.user._challenges.join(';'))
        throw cds.error('Unauthorized', { statusCode: 401, code: '401' })
      }
      throw cds.error('Forbidden', { statusCode: 403, code: '403' })
    }

    next()
  })

  // -----------------------------------------------------------------------------------------
  // service root
  //
  router.head('/', (_, res) => res.json({}))
  router.get('/', (_, res) =>
    res.json({
      entities: Object.keys(srv.entities).map(e => ({ name: e, url: e }))
    })
  )

  // -----------------------------------------------------------------------------------------
  // parse / validate
  //
  // content-type check
  router.use((req, res, next) => {
    // REVISIT: move that into parse function
    if (req.method in { POST: 1, PUT: 1, PATCH: 1 }) {
      const contentType = req.headers['content-type'] && req.headers['content-type'].split(';')
      if (
        contentType &&
        (!contentType[0].match(/^application\/json$/) || (typeof contentType[1] === 'string' && !contentType[1]))
      ) {
        throw cds.error('INVALID_CONTENT_TYPE_ONLY_JSON', { statusCode: 415, code: '415' }) // FIXME: better i18n + use res.status
      }

      if (req.method in { PUT: 1, PATCH: 1 }) {
        if (Array.isArray(req.body)) {
          throw cds.error(`INVALID_${req.method}`, { statusCode: 400, code: '400' }) // FIXME: better i18n + use res.status
        }

        // REVISIT: empty object length is not 0
        // REVISIT: also check for POST?
        // check for empty payload body
        if (req.headers['content-length'] === '0') {
          res.status(400).json({ error: { message: 'Malformed patch document', statusCode: 400, code: '400' } })
          return
        }
      }
    }
    next()
  })
  router.use(express.json())
  router.use(parse_factory(srv))

  // -----------------------------------------------------------------------------------------
  // begin tx
  //
  router.use((req, res, next) => {
    // REVISIT: -> move to actual handler(s)
    const tenant = req.tenant || req.user?.tenant
    // create tx and set as cds.context
    cds.context = srv.tx(new cds.EventContext({ user: req.user, req, res, tenant }))
    next()
  })

  // -----------------------------------------------------------------------------------------
  // Actual handlers for HEAD, GET, PUT, POST, PATCH, DELETE
  //
  const operation = operation_factory(srv)
  const create = create_factory(srv)
  const read = read_factory(srv)
  const update = update_factory(srv)
  const deleet = delete_factory(srv)
  router.use(async (req, res, next) => {
    try {
      let result, status, location

      if (req._operation) {
        // actions and functions
        ;({ result, status } = await operation(req, res))
      } else {
        // CRUD
        switch (req.method) {
          case 'POST':
            ;({ result, status, location } = await create(req))
            break
          case 'HEAD':
          case 'GET':
            ;({ result, status } = await read(req))
            break
          case 'PUT':
          case 'PATCH':
            ;({ result, status } = await update(req))
            break
          case 'DELETE':
            ;({ result, status } = await deleet(req))
            break
        }
      }

      req._result = { result, status, location }
      return next()
    } catch (e) {
      next(e)
    }
  })

  // -----------------------------------------------------------------------------------------
  // end tx (i.e., commit or rollback)
  //
  router.use(async (req, res, next) => {
    const { result, status, location } = req._result // REVISIT: Ugly voodoo _req._result channel -> eliminate

    // unfortunately, express doesn't catch async errors -> try catch needed
    try {
      await cds.context?.tx?.commit(result)
    } catch (e) {
      return next(e)
    }

    // if authentication or something else within the processing of a cds.Request terminates the request, no need to continue
    if (res.headersSent) return

    // convert binaries
    let definition = req._operation || req._query.__target
    if (typeof definition === 'string')
      definition =
        srv.model.definitions[definition] ||
        srv.model.definitions[definition.split(':$:')[0]].actions[definition.split(':$:')[1]]
    if (result && srv && definition) bufferToBase64(result, srv, definition)

    // only set status if not yet modified
    if (status && res.statusCode === 200) res.status(status) // REVISIT: Why only when res.statusCode === 200?
    if (location) res.set('location', location) // REVISIT: When do we redirect?
    if (req.method === 'HEAD')
      // REVISIT: Move that to the implementation of HEAD
      res
        .set({
          'content-type': 'application/json; charset=utf-8',
          'content-length': JSON.stringify(result).length
        })
        .end()
    // need to convert number to string because express interprets integer as status code
    else res.send(typeof result === 'number' ? result.toString() : result) // REVISIT: use req.json() instead?
  })

  // -----------------------------------------------------------------------------------------
  // error handling
  //
  router.use(async (err, req, res, next) => {
    // REVISIT: should not be neccessary!
    // request may fail during processing or during commit -> both caught here

    // REVISIT: rollback needed if error occured before commit attempted -> how to distinguish?
    await cds.context?.tx?.rollback(err).catch(() => {}) // REVISIT: silently ?!?

    next(err)
  })

  if (!cds.env.features.rest_error_handler) {
    router.use(error_factory(srv)) // FIXME: nope -> call next()
  }

  return router
}

module.exports = RestAdapter
