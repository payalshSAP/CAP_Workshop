const cds = require('../../_runtime/cds')
const { INSERT } = cds.ql

const RestRequest = require('../RestRequest')

const UPSERT_ALLOWED = !(cds.env.runtime && cds.env.runtime.allow_upsert === false)

const { deepCopyObject } = require('../../_runtime/common/utils/copy')

module.exports = srv => async _req => {
  let { _query: query, _target, _data, _params } = _req

  let result,
    status = 200

  // if upsert it allowed, we need to catch 404 and retry with create
  try {
    // add the data (as copy, if upsert allowed)
    query.data(UPSERT_ALLOWED ? deepCopyObject(_data) : _data)

    // REVISIT: if PUT, req.method should be PUT -> Crud2Http maps UPSERT to PUT
    result = await srv.dispatch(new RestRequest({ query, _target, method: _req.method, params: _params }))
    if (_params && result) Object.assign(result, _params[_params.length - 1])
  } catch (e) {
    const is404 = e.code === 404 || e.status === 404 || e.statusCode === 404
    const isForcedInsert =
      (e.code === 412 || e.status === 412 || e.statusCode === 412) && _req.headers['if-none-match'] === '*'
    if ((is404 || isForcedInsert) && UPSERT_ALLOWED) {
      query = INSERT.into(query.UPDATE.entity).entries(
        _params ? Object.assign(_data, _params[_params.length - 1]) : _data
      )
      result = await srv.dispatch(new RestRequest({ query, _target, params: _params }))
      status = 201
    } else {
      throw e
    }
  }

  return { result, status }
}
