const cds = require('../../../')
const { INSERT } = cds.ql

const { toODataResult, postProcess } = require('../utils/result')
const {
  calculateLocationHeader,
  getKeysAndParamsFromPath,
  handleSapMessages,
  getPreferReturnHeader
} = require('../utils')
const { getDeepSelect, getSimpleSelectCQN } = require('../utils/handler')

const { deepCopy } = require('../../_runtime/common/utils/copy')

const readAfterWrite = require('../utils/readAfterWrite')
const metaInfo = require('../utils/metaInfo')

module.exports = srv =>
  function create(req, res, next) {
    const {
      SELECT: { one, from },
      target
    } = req._query

    // req.__proto__.method is set in case of upsert
    const isUpsert = req.__proto__.method in { PUT: 1, PATCH: 1 }

    if (one && !isUpsert) {
      const msg = 'Method POST is not allowed for singletons and individual entities'
      throw Object.assign(new Error(msg), { statusCode: 405 })
    }

    // payload & params
    const data = deepCopy(req.body)
    const { keys, params } = getKeysAndParamsFromPath(from, srv)
    // add keys from url into payload (overwriting if already present)
    Object.assign(data, keys)

    // assert payload
    const assertOptions = { filter: true, http: { req }, mandatories: true }
    const errs = cds.assert(data, target, assertOptions)
    if (errs) {
      if (errs.length === 1) throw errs[0]
      throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
    }

    // query
    const query = INSERT.into(from).entries(data)

    // cdsReq.headers should contain merged headers of envelope and subreq
    const headers = { ...cds.context.http.req.headers, ...req.headers }

    // we need a cds.Request for multiple reasons, incl. params, headers, sap-messages, read after write, ...
    const cdsReq = new cds.Request({ query, params, headers, req, res })
    Object.defineProperty(cdsReq, 'protocol', { value: 'odata-v4' })

    // API for subrequests of $batch (or incoming request)
    cdsReq.req = req
    cdsReq.res = res

    // rewrite event for draft-enabled entities
    if (target._isDraftEnabled) cdsReq.event = 'NEW'

    // REVISIT: only via srv.run in combination with srv.dispatch inside
    //          we automatically either use a single auto-managed tx for the req (i.e., insert and read after write in same tx)
    //          or the auto-managed tx opened for the respective atomicity group, if exists
    return srv
      .run(() => {
        return srv.dispatch(cdsReq).then(result => {
          handleSapMessages(cdsReq, req, res)

          // generic handlers indicate that read after write is required
          if (cdsReq._.readAfterWrite) {
            // const keys = cdsReq.target.keys?.filter(k => !k.isAssociation)?.reduce((prev, k) => { prev[k] = result[k]; return prev}, {}  )
            // const query = SELECT.one(cdsReq.query.INSERT.into, keys)
            const query = cdsReq.event === 'NEW' ? getSimpleSelectCQN(cdsReq.target, result) : getDeepSelect(cdsReq)
            return readAfterWrite(cdsReq, srv, query)
          }

          return result
        })
      })
      .then(result => {
        // we use an extra then block, after getting the result, so the transaction is commited, before sending the response

        // determine calculation based on result with req.data as fallback
        if (!target._isSingleton)
          res.set('location', calculateLocationHeader(cdsReq.target, srv, result || cdsReq.data))

        if (result == null) return res.sendStatus(204)
        const isMinimal = getPreferReturnHeader(req) === 'minimal'
        postProcess(cdsReq.target, srv, result, isMinimal)

        if (result['$etag']) res.set('etag', result['$etag'])
        if (isMinimal) return res.sendStatus(204)

        const info = metaInfo(query, 'CREATE', srv, result, req)
        result = toODataResult(result, info)
        res.set('content-type', 'application/json;IEEE754Compatible=true')
        res.status(201).send(result)
      })
      .catch(err => {
        handleSapMessages(cdsReq, req, res)
        next(err)
      })
  }
