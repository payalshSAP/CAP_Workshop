const cds = require('../../../')
const { UPDATE } = cds.ql

const { toODataResult, postProcess } = require('../utils/result')
const { getKeysAndParamsFromPath, handleSapMessages, getPreferReturnHeader } = require('../utils')
const { deepCopy } = require('../../_runtime/common/utils/copy')

const readAfterWrite = require('../utils/readAfterWrite')
const metaInfo = require('../utils/metaInfo')

const _isUpsertAllowed = ({ target, data, event }) => {
  return (
    !(cds.env.runtime && cds.env.runtime.allow_upsert === false) &&
    !(target && target._isDraftEnabled && (!cds.env.fiori.lean_draft || (!data.IsActiveEntity && event === 'PATCH')))
  )
}

const _isNavigationWithKeyInParent = (keys, data, pathExpression, model) => {
  // keys not in data
  if (keys && Object.keys(keys).some(key => key in data)) {
    return false
  }

  const nav = pathExpression.ref && pathExpression.ref.length !== 0 && pathExpression.ref[1]
  const parent = pathExpression.ref && pathExpression.ref[0].id

  // not a navigation
  if (!parent || !nav) {
    return false
  }

  const navID = typeof nav === 'string' ? nav : nav.id
  const navElement = model.definitions[parent].elements[navID]

  // not a containment
  if (!navElement._isContained) {
    return false
  }

  const where = pathExpression.ref[0].where
  return parent && navElement && where
}

module.exports = (srv, router) =>
  function update(req, res, next) {
    // REVISIT: better solution for _propertyAccess
    const {
      SELECT: { one, from },
      target,
      _propertyAccess
    } = req._query

    // REVISIT: patch on collection is allowed in odata 4.01
    if (!one) {
      throw Object.assign(new Error(`Method ${req.method} is not allowed for entity collections`), { statusCode: 405 })
    }

    if (_propertyAccess && req.method === 'PATCH') {
      throw Object.assign(new Error(`Method ${req.method} is not allowed for properties`), { statusCode: 405 })
    }

    // payload & params
    let data = _propertyAccess ? { [_propertyAccess]: req.body.value } : deepCopy(req.body)
    const { keys, params } = getKeysAndParamsFromPath(from, srv)
    // add keys from url into payload (overwriting if already present)
    if (!_propertyAccess) Object.assign(data, keys)

    // assert payload
    if (!_propertyAccess) {
      // assert complex
      const assertOptions = { filter: true, http: { req }, mandatories: req.method === 'PUT' || undefined }
      const errs = cds.assert(data, target, assertOptions)
      if (errs) {
        if (errs.length === 1) throw errs[0]
        throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
      }
    } else {
      // TODO: assert primitive
    }

    // query
    let query = UPDATE.entity(from).with(data)

    // cdsReq.headers should contain merged headers of envelope and subreq
    const headers = { ...cds.context.http.req.headers, ...req.headers }

    // we need a cds.Request for multiple reasons, incl. params, headers, sap-messages, read after write, ...
    let cdsReq = new cds.Request({ query, params, headers, req, res })
    Object.defineProperty(cdsReq, 'protocol', { value: 'odata-v4' })

    // API for subrequests of $batch (or incoming request)
    cdsReq.req = req
    cdsReq.res = res

    // REVISIT: adjust in getter?
    if (req.method === 'PUT') cdsReq.method = 'PUT'

    // rewrite event for draft-enabled entities
    if (target._isDraftEnabled) cdsReq.event = 'PATCH'

    // REVISIT: only via srv.run in combination with srv.dispatch inside
    //          we automatically either use a single auto-managed tx for the req (i.e., insert and read after write in same tx)
    //          or the auto-managed tx opened for the respective atomicity group, if exists
    return srv
      .run(() => {
        return srv.dispatch(cdsReq).then(result => {
          handleSapMessages(cdsReq, req, res)

          // TODO: any other checks needed?
          if (cdsReq._.readAfterWrite && !(_propertyAccess && !target._etag)) {
            return readAfterWrite(cdsReq, srv, SELECT.one(cdsReq.subject))
          }

          return result
        })
      })
      .then(result => {
        // we use an extra then block, after getting the result, so the transaction is commited, before sending the response

        if (result == null) return res.sendStatus(204)

        // REVISIT: metaInfo needs original query in case of property access, but why?
        const info = metaInfo(_propertyAccess ? req._query : query, 'UPDATE', srv, result, req)

        const isMinimal = getPreferReturnHeader(req) === 'minimal'

        postProcess(cdsReq.target, srv, result, isMinimal)

        if (result['$etag']) res.set('etag', result['$etag'])

        if (isMinimal || (query._propertyAccess && result[query._propertyAccess] == null) || info.metadata.isStream) {
          return res.sendStatus(204)
        }

        result = toODataResult(result, info)
        res.set('content-type', 'application/json;IEEE754Compatible=true')
        res.send(result)
      })
      .catch(e => {
        // if UPSERT is allowed, redirect to POST
        const is404 = e.code === 404 || e.status === 404 || e.statusCode === 404
        const isForcedInsert =
          (e.code === 412 || e.status === 412 || e.statusCode === 412) && req.headers['if-none-match'] === '*'
        if (!_propertyAccess && (is404 || isForcedInsert) && _isUpsertAllowed({ target, data, event: req.method })) {
          // PUT / PATCH with if-match header means "only if already exists" -> no insert if it does not
          if (req.headers['if-match']) {
            return next(Object.assign(new Error('412'), { statusCode: 412 }))
          }
          // (check only works with req.body and not with data)
          if (_isNavigationWithKeyInParent(target.keys, req.body, from, srv.model)) {
            return next(Object.assign(new Error('422'), { statusCode: 422 }))
          }
          // -> redirect to POST
          return router.handle(Object.assign(Object.create(req), { method: 'POST' }), res)
        }

        handleSapMessages(cdsReq, req, res)

        // continue with caught error
        next(e)
      })
  }
