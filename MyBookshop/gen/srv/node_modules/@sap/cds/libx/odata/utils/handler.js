const cds = require('../../_runtime/cds')
const { SELECT } = cds.ql

const { DRAFT_COLUMNS_MAP } = require('../../_runtime/common/constants/draft')

const _keysOf = (row, target) => {
  const keyElements = Object.values(target.keys || {}).filter(v => !v.virtual)
  // > singleton
  if (!keyElements.length) return
  const keys = {}
  for (const key of keyElements) {
    if (key._isAssociationStrict) continue
    if (row[key.name] === undefined) continue // key is not in data, so ignore it
    keys[key.name] = key.elements ? { val: JSON.stringify(row[key.name]) } : row[key.name]
  }
  return keys
}

const getSimpleSelectCQN = (target, data, columns, subject) => {
  const keys = _keysOf(data, target)
  // don't use `ql.where()` to get `where` in `from` for location header
  let cqn
  // reflect request path in read after write
  if (subject?.ref.length > 1) {
    cqn = SELECT.one(subject)
    if (keys) cqn.where(keys)
  } else {
    cqn = keys ? SELECT.one(target, keys) : /* singleton */ SELECT.one(target)
  }

  if (columns) {
    cqn.columns(...columns)
  }

  if (target.query && target.query.SELECT && target.query.SELECT.orderBy) {
    cqn.SELECT.orderBy = target.query.SELECT.orderBy
  }

  return cqn
}

const _mergeExpandCQNs = cqns => {
  const cols = cqns[0].SELECT.columns
  for (const cqn of cqns.slice(1)) {
    for (const col of cqn.SELECT.columns) {
      if (!col.expand) continue
      const idx = cols.findIndex(ele => {
        if (!col.ref) return
        if (ele.ref) return ele.ref[0] === col.ref[0]
        if (ele.as) return ele.as === col.ref[0]
      })
      if (idx === -1) {
        cols.push(col)
      } else {
        const colExists = cols[idx]
        if (colExists.as && colExists.val === null) {
          cols[idx] = col
          continue
        }
        if (col.as && col.val === null) continue
        const mergedExpandCQN = _mergeExpandCQNs([
          { SELECT: { columns: colExists.expand } },
          { SELECT: { columns: col.expand } }
        ])
        colExists.expand = mergedExpandCQN.SELECT.columns
      }
    }
  }
  return cqns[0]
}

const _getExpandColumn = (data, element) => {
  const key = element.name
  if (!(key in data)) return
  data = data[key]
  if ((Array.isArray(data) && data.length === 0) || data == null) {
    // performance tweak, keep in mind it is only for compositions
    return { val: null, as: key }
  }
  const cqn = Array.isArray(data)
    ? _mergeExpandCQNs(data.map(data => getDeepSelect({ target: element._target, data })))
    : getDeepSelect({ target: element._target, data })
  return { ref: [key], expand: cqn.SELECT.columns }
}

const _getColumns = (target, data, prefix = []) => {
  const columns = []
  for (const each in target.elements) {
    if (target.elements[each]['@cds.api.ignore']) continue
    if (each in DRAFT_COLUMNS_MAP) continue
    if (!cds.env.features.stream_compat && target.elements[each].type === 'cds.LargeBinary') continue
    const element = target.elements[each]
    if (element.elements && data[each]) {
      prefix.push(element.name)
      columns.push(..._getColumns(element, data[each], prefix))
      prefix.pop()
    } else if (element.isComposition && !prefix.length) {
      const col = _getExpandColumn(data, element, prefix)
      if (col) columns.push(col)
    } else if (!element.isAssociation) {
      columns.push({ ref: [...prefix, each] })
    }
  }
  return columns
}

/*
 * recursively builds a select cqn for deep read after write
 * (depth determined by req.data)
 */
const getDeepSelect = req => {
  let { target, data, subject } = req
  const columns = _getColumns(target, data)
  return getSimpleSelectCQN(target, data, columns, subject)
}

module.exports = {
  getDeepSelect,
  getSimpleSelectCQN
}
