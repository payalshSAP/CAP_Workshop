const cds = require('../../../')
const { AsyncResource } = require('async_hooks')

// eslint-disable-next-line cds/no-missing-dependencies
const express = require('express')
const { STATUS_CODES } = require('http')
const qs = require('querystring')
const { URL } = require('url')

const multipartToJson = require('../parse/multipartToJson')

const HTTP_METHODS = { GET: 1, POST: 1, PUT: 1, PATCH: 1, DELETE: 1 }
const CT = { JSON: 'application/json', MULTIPART: 'multipart/mixed' }
const CRLF = '\r\n'

/*
 * common
 */

const _deserializationError = message => cds.error(`Deserialization Error: ${message}`, { code: 400 })

// Function must be called with an object containing exactly one key-value pair representing the property name and its value
const _validateProperty = (name, value, type) => {
  if (value === undefined) throw _deserializationError(`Parameter '${name}' must not be undefined.`)

  switch (type) {
    case 'Array':
      if (!Array.isArray(value)) throw _deserializationError(`Parameter '${name}' must be type of '${type}'.`)
      break
    default:
      if (typeof value !== type) throw _deserializationError(`Parameter '${name}' must be type of '${type}'.`)
  }
}

const _validateBatch = body => {
  const { requests } = body

  _validateProperty('requests', requests, 'Array')

  if (requests.length > cds.env.odata.batch_limit)
    cds.error('BATCH_TOO_MANY_REQ', { code: 'BATCH_TOO_MANY_REQ', statusCode: 429 })

  const ids = {}

  let previousAtomicityGroup
  requests.forEach((request, i) => {
    if (typeof request !== 'object')
      throw _deserializationError(`Element of 'requests' array at index ${i} must be type of 'object'.`)

    const { id, method, url, body, atomicityGroup, dependsOn } = request

    _validateProperty('id', id, 'string')

    if (ids[id]) throw _deserializationError(`Request ID '${id}' is not unique.`)
    else ids[id] = request

    // TODO: validate allowed methods or let express throw the error?
    _validateProperty('method', method, 'string')
    if (!(method.toUpperCase() in HTTP_METHODS))
      throw _deserializationError(`Method '${method}' is not allowed. Only DELETE, GET, PATCH, POST or PUT are.`)

    _validateProperty('url', url, 'string')
    // TODO: need similar validation in multipart/mixed batch
    if (url.startsWith('/$batch')) throw _deserializationError('Nested batch requests are not allowed.')

    // TODO: support for non JSON bodies?
    if (body !== undefined && typeof body !== 'object')
      throw _deserializationError('A Content-Type header has to be specified for a non JSON body.')

    // TODO
    // if (!(method.toUpperCase() in { GET: 1, DELETE: 1 }) && !body)
    //   throw _deserializationError(`Body is required for ${method} requests.`)

    if (atomicityGroup) {
      _validateProperty('atomicityGroup', atomicityGroup, 'string')

      // All request objects with the same value for atomicityGroup MUST be adjacent in the requests array
      if (atomicityGroup !== previousAtomicityGroup) {
        if (ids[atomicityGroup]) throw _deserializationError(`Atomicity group ID '${atomicityGroup}' is not unique.`)
        else ids[atomicityGroup] = [request]
      } else {
        ids[atomicityGroup].push(request)
      }
    }

    if (dependsOn) {
      _validateProperty('dependsOn', dependsOn, 'Array')
      dependsOn.forEach(dependsOnId => {
        _validateProperty('dependent request ID', dependsOnId, 'string')

        const dependency = ids[dependsOnId]
        if (!dependency)
          throw _deserializationError(`Request ID '${dependsOnId}' used in dependsOn has not been defined before.`)

        const dependencyAtomicityGroup = dependency.atomicityGroup
        if (dependencyAtomicityGroup && !dependsOn.includes(dependencyAtomicityGroup))
          throw _deserializationError(
            `The group '${dependencyAtomicityGroup}' of the referenced request '${dependsOnId}' must be listed in dependsOn of request '${id}'.`
          )
      })
    }

    // TODO: validate if, and headers

    previousAtomicityGroup = atomicityGroup
  })

  return ids
}

const _createExpressReqResLookalike = (request, _req, _res) => {
  const { id, method, url } = request
  const ret = { id }

  const req = (ret.req = new express.request.constructor())
  req.__proto__ = express.request

  // express internals
  req.app = _req.app

  req.method = method.toUpperCase()
  req.url = url
  const u = new URL(url, 'http://cap')
  req.query = qs.parse(u.search.slice(1))
  req.headers = request.headers || {}
  req.body = request.body

  const res = (ret.res = new express.response.constructor(req))
  res.__proto__ = express.response

  // express internals
  res.app = _res.app

  // back link
  req.res = res

  // resolve promise for subrequest via res.end()
  ret.promise = new Promise((resolve, _reject) => {
    res.end = (chunk, encoding) => {
      res._chunk = chunk
      res._encoding = encoding
      resolve(ret)
    }
  })

  return ret
}

const _transaction = async (srv, router) => {
  return new Promise(res => {
    const ret = {}
    srv.tx(
      async () =>
        (ret.promise = new Promise((resolve, reject) => {
          const proms = []
          ret.add = AsyncResource.bind(function (request, req, res) {
            const lookalike = _createExpressReqResLookalike(request, req, res)
            router.handle(lookalike.req, lookalike.res)
            request.promise = lookalike.promise
            proms.push(request.promise)
            return request.promise
          })
          ret.done = function () {
            return Promise.allSettled(proms).then(resolve, reject)
          }
          res(ret)
        }))
    )
  })
}

const _processBatch = async (srv, router, req, res, next, body, ct, boundary) => {
  body ??= req.body
  ct ??= 'JSON'
  const isJson = ct === 'JSON'
  const _formatResponse = isJson ? _formatResponseJson : _formatResponseMultipart

  try {
    const ids = _validateBatch(body) // REVISIT: we will not be able to validate the whole once we stream

    // TODO: if (!requests || !requests.length) throw new Error('At least one request, buddy!')

    let previousAtomicityGroup
    let separator
    let tx

    res.setHeader('content-type', CT[ct] + (!isJson ? ';boundary=' + boundary : ''))
    res.setHeader('OData-Version', '4.0') //> REVISIT: Fiori/ UI5 wants this
    res.status(200)
    res.write(isJson ? '{"responses":[' : '')

    const { requests } = body
    for await (const request of requests) {
      const { atomicityGroup } = request

      if (!atomicityGroup || atomicityGroup !== previousAtomicityGroup) {
        if (tx) await tx.done()
        tx = await _transaction(srv, router)
        if (atomicityGroup) ids[atomicityGroup].promise = tx.promise
      }

      const dependencies = request.dependsOn?.map(id => ids[id].promise)
      if (dependencies) {
        // TODO: fail the dependent request if dependency fails
        await Promise.allSettled(dependencies)
      }

      tx.add(request, req, res).then(request => {
        if (separator) res.write(separator)
        else separator = isJson ? Buffer.from(',') : Buffer.from(CRLF)
        _formatResponse(request, res, boundary)
      })

      if (!atomicityGroup) tx.done()

      previousAtomicityGroup = atomicityGroup
    }

    if (tx) await tx.done()

    res.write(isJson ? ']}' : `${CRLF}--${boundary}--${CRLF}`)
    res.end()

    return
  } catch (e) {
    next(e)
  }
}

/*
 * multipart/mixed
 */

const _multipartBatch = (srv, router) => async (req, res, next) => {
  const boundary = req.headers['content-type']?.match(/boundary=([\w_-]+)/i)?.[1]
  if (!boundary) return next(cds.error('No boundary found in Content-Type header', { code: 400 }))

  try {
    const { requests } = await multipartToJson(req.body, boundary)
    _processBatch(srv, router, req, res, next, { requests }, 'MULTIPART', boundary)
  } catch (e) {
    next(e)
  }
}

const _formatResponseMultipart = (request, res, boundary) => {
  const { /* id, */ res: response } = request

  let txt = `--${boundary}${CRLF}content-type: application/http${CRLF}content-transfer-encoding: binary${CRLF}${CRLF}`
  txt += `HTTP/1.1 ${response.statusCode} ${STATUS_CODES[response.statusCode]}${CRLF}`

  // REVISIT: tests require specific sequence
  const headers = {
    'odata-version': '4.0',
    'content-type': 'DUMMY',
    ...response.getHeaders()
  }
  headers['content-type'] = 'application/json;odata.metadata=minimal' //> REVISIT: expected by tests
  delete headers['content-length'] //> REVISIT: expected by tests
  for (const key in headers) {
    txt += key + ': ' + headers[key] + CRLF
  }
  txt += CRLF

  if (response._chunk) {
    let _json
    try {
      // REVISIT: tests require specific sequence -> fix and simply use res._chunk
      _json = JSON.parse(response._chunk)
      if (typeof _json !== 'object') throw new Error('not an object')
      let meta = [],
        data = []
      for (const [k, v] of Object.entries(_json)) {
        if (k.startsWith('@')) meta.push(`"${k}":"${v.replaceAll('"', '\\"')}"`)
        else data.push(JSON.stringify({ [k]: v }).slice(1, -1))
      }
      const _json_as_txt = '{' + meta.join(',') + (meta.length && data.length ? ',' : '') + data.join(',') + '}'
      txt += _json_as_txt
    } catch {
      // ignore error and take chunk as is (a text)
      txt += response._chunk
      txt = txt.replace('content-type: application/json;odata.metadata=minimal', 'content-type: text/plain')
    }
  }

  res.write(txt)
}

/*
 * application/json
 */

const _formatStatics = {
  comma: ','.charCodeAt(0),
  body: Buffer.from('"body":'),
  close: Buffer.from('}')
}

const _formatResponseJson = (request, res) => {
  const { id, res: response } = request
  const raw = Buffer.from(
    JSON.stringify({
      id,
      status: response.statusCode,
      headers: {
        'odata-version': '4.0',
        'content-type': 'application/json',
        ...response.getHeaders()
      }
    })
  )
  // change last "}" into ","
  raw[raw.byteLength - 1] = _formatStatics.comma
  res.write(raw)
  res.write(_formatStatics.body)
  res.write(response._chunk)
  res.write(_formatStatics.close)
}

const _jsonBatch = (srv, router) => (req, res, next) => {
  _processBatch(srv, router, req, res, next)
}

module.exports = (srv, router) => {
  const handleJsonBatch = _jsonBatch(srv, router)
  const handleMultipartBatch = _multipartBatch(srv, router)

  return function batch(req, res, next) {
    if (req.headers['content-type'].includes('application/json')) {
      return handleJsonBatch(req, res, next)
    }

    if (req.headers['content-type'].includes('multipart/mixed')) {
      return express.text({ type: '*/*' })(req, res, () => {
        handleMultipartBatch(req, res, next)
      })
    }

    throw cds.error('Batch requests must have content type multipart/mixed or application/json', { code: 400 })
  }
}
