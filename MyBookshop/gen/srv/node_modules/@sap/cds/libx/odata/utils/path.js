const { where2obj } = require('../../_runtime/common/utils/cqn')

const _handleXpr = (relation, keys, seg_keys) => {
  const join = [...relation]
  while (join.length >= 3) {
    // eslint-disable-next-line no-unused-vars
    const [left, _, right] = join

    if (left.xpr) {
      // can be [ref = ref] or [xpr and ref = ref] and [xpr and xpr] so we will always catch xprs as left element, as it follows and/or or is first element
      _handleXpr(left.xpr, keys, seg_keys)
      join.splice(0, 2)
      continue
    }

    if (left.ref?.[0] === 'target') {
      if (left.ref[1] in keys) break // we already added the foreign key for the last segment
      const keyValue = 'val' in right ? right.val : seg_keys[right.ref[1]]
      if (keyValue !== undefined) keys[left.ref[1]] = keyValue
      join.splice(0, 4)
    } else if (right.ref?.[0] === 'target') {
      if (right.ref[1] in keys) break // we already added the foreign key for the last segment
      const keyValue = 'val' in left ? left.val : seg_keys[left.ref[1]]
      if (keyValue !== undefined) keys[right.ref[1]] = keyValue
      join.splice(0, 4)
    }
  }
}

// REVISIT: do we already have something like this _without using okra api_?
// REVISIT: should we still support process.env.CDS_FEATURES_PARAMS? probably nobody uses it...
const getKeysAndParamsFromPath = (from, srv) => {
  if (!from.ref) return {}

  const keys = {}
  const params = []

  // last path segment
  if (from.ref[from.ref.length - 1].where) {
    const seg_keys = where2obj(from.ref[from.ref.length - 1].where)
    Object.assign(keys, seg_keys)
    params.unshift(seg_keys.ID && Object.keys(seg_keys).length === 1 ? seg_keys.ID : seg_keys)
  }

  // previous path segments
  if (from.ref.length > 1) {
    const entities = []
    let cur = srv.model.definitions
    for (let i = 0; i < from.ref.length; i++) {
      const id = from.ref[i].id || from.ref[i]
      const t = cur[id]._target || cur[id]
      entities.push(t)
      cur = t.elements
    }
    for (let i = from.ref.length - 2; i >= 0; i--) {
      const ref = from.ref[i]
      if (ref.where) {
        const relation = entities[i]._relations[from.ref[i + 1].id || from.ref[i + 1]].join('target', 'source')
        const seg_keys = where2obj(ref.where)
        if (relation?.[0].xpr) {
          _handleXpr(relation[0].xpr, keys, seg_keys)
        } else {
          // REVISIT: what to do here?
        }
        params.unshift(seg_keys.ID && Object.keys(seg_keys).length === 1 ? seg_keys.ID : seg_keys)
      }
    }
  }

  return { keys, params }
}

module.exports = {
  getKeysAndParamsFromPath
}
