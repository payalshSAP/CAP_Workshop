const cds = require('../../../')

const { toODataResult, postProcess } = require('../utils/result')
const { cds2edm, getKeysAndParamsFromPath, handleSapMessages } = require('../utils')

const { deepCopy } = require('../../_runtime/common/utils/copy')

const metaInfo = require('../utils/metaInfo')

module.exports = srv =>
  function operation(req, res, next) {
    let { operation, args } = req._query.SELECT?.from.ref?.slice(-1)[0] || {}
    if (!operation) return next() //> create or read

    // unbound vs. bound
    let entity, /* keys, */ params
    if (srv.model.definitions[operation]) {
      operation = srv.model.definitions[operation]
    } else {
      req._query.SELECT.from.ref.pop()
      let cur = { elements: srv.model.definitions }
      for (const each of req._query.SELECT.from.ref) {
        cur = cur.elements[each.id || each]
        if (cur._target) cur = cur._target
      }
      operation = cur.actions[operation]
      entity = cur
      const keysAndParams = getKeysAndParamsFromPath(req._query.SELECT.from, srv)
      params = keysAndParams.params
    }

    // payload & params
    const data = args || deepCopy(req.body)

    // assert payload
    const assertOptions = { filter: true, http: { req }, mandatories: true }
    const errs = cds.assert(data, operation, assertOptions)
    if (errs) {
      if (errs.length === 1) throw errs[0]
      throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
    }

    // event
    // REVISIT: when is operation.name actually prefixed with the service name?
    const event = operation.name.replace(`${srv.name}.`, '')

    const query = entity ? req._query : undefined

    // cdsReq.headers should contain merged headers of envelope and subreq
    const headers = { ...cds.context.http.req.headers, ...req.headers }

    // we need a cds.Request for multiple reasons, incl. params, headers, sap-messages, read after write, ...
    const cdsReq = new cds.Request({ query, event, data, params, headers, target: query?.target, req, res })
    Object.defineProperty(cdsReq, 'protocol', { value: 'odata-v4' })

    // API for subrequests of $batch (or incoming request)
    cdsReq.req = req
    cdsReq.res = res

    // REVISIT: only via srv.run in combination with srv.dispatch inside
    //          we automatically either use a single auto-managed tx for the req (i.e., insert and read after write in same tx)
    //          or the auto-managed tx opened for the respective atomicity group, if exists
    return srv
      .run(() => {
        return srv.dispatch(cdsReq).then(result => {
          handleSapMessages(cdsReq, req, res)
          return result
        })
      })
      .then(result => {
        // we use an extra then block, after getting the result, so the transaction is commited, before sending the response

        if (!operation.returns || result == null) return res.status(204).end()

        if (operation.returns._type?.match?.(/^cds\./)) {
          res.set('content-type', 'application/json;IEEE754Compatible=true')
          // TODO: check result type
          return res.send({
            '@odata.context': `${'../'.repeat(query?.SELECT?.from?.ref?.length)}$metadata#${cds2edm[operation.returns._type]}`,
            value: result
          })
        }

        const info = metaInfo(req._query, event, srv, result, req)

        // FIXME: info.metadata.isCollection is incorrect
        if (!operation.returns.items) info.metadata.isCollection = false

        // REVISIT impl of context url generation
        if (
          !info.metadata.isCollection &&
          info.metadata.isServiceEntity &&
          !info.metadata.contextUrl.endsWith('$entity')
        ) {
          info.metadata.contextUrl += '/$entity'
        }

        if (info.metadata.returnType) {
          postProcess(info.metadata.returnType, srv, result)
          if (result['$etag']) res.set('etag', result['$etag'])
        }

        result = toODataResult(result, info)

        // FIXME: toODataResult() doesn't seem to handle this case
        if (entity && !result['@odata.context'].match(/^\.\.\//))
          result['@odata.context'] = '../' + result['@odata.context']

        res.set('content-type', 'application/json;IEEE754Compatible=true')
        res.send(result)
      })
      .catch(err => {
        handleSapMessages(cdsReq, req, res)
        next(err)
      })
  }
