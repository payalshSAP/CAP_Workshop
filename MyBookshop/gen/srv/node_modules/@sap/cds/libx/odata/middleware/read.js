const cds = require('../../../')
const { toODataResult, postProcess } = require('../utils/result')
const querystring = require('node:querystring')
const { getKeysAndParamsFromPath, handleSapMessages, validateIfNoneMatch, getPreferReturnHeader } = require('../utils')
const { handleStreamProperties } = require('../../_runtime/common/utils/streamProp')

const metaInfo = require('../utils/metaInfo')
const { getPageSize } = require('../../_runtime/common/generic/paging')

const _getCount = result =>
  Array.isArray(result)
    ? result.reduce((acc, val) => {
        return acc + ((val && (val.$count || val._counted_)) || (val[0] && (val[0].$count || val[0]._counted_))) || 0
      }, 0)
    : result.$count || result._counted_ || 0

const _calculateNextLink = (req, result) => {
  const $skiptoken = result.$nextLink ?? _calculateSkiptoken(req, result)
  if ($skiptoken) {
    const queryParamsWithSkipToken = { ...req.req.query, $skiptoken }
    // REVISIT: slice replaces leading '/'. Always starts with '/'?
    result.$nextLink =
      req.req.path.slice(1) +
      '?' +
      querystring.stringify(queryParamsWithSkipToken, '&', '=', { encodeURIComponent: e => e })
  }
}

const _calculateSkiptoken = (req, result) => {
  const limit = Array.isArray(req.query) ? getPageSize(req.query[0]._target).max : req.query.SELECT.limit?.rows?.val
  const top = parseInt(req.req.query.$top)
  if (limit === result.length && limit !== top) {
    const token = req.req.query.$skiptoken
    if (cds.env.query.limit.reliablePaging && _reliablePagingPossible(req)) {
      const decoded = token && JSON.parse(Buffer.from(token, 'base64').toString())
      const skipToken = {
        r: (decoded?.r || 0) + limit,
        c: req.query.SELECT.orderBy.map(o => ({
          a: o.sort ? o.sort === 'asc' : true,
          k: o.ref[0],
          v: result[result.length - 1][o.ref[0]]
        }))
      }

      if (limit + (decoded?.r || 0) !== top) {
        return Buffer.from(JSON.stringify(skipToken)).toString('base64')
      }
    } else {
      return (token ? parseInt(token) : 0) + limit
    }
  }
}

const _reliablePagingPossible = req => {
  if (req.target._isDraftEnabled) return false
  if (cds.context?.http.req.query.$apply) return false
  if (req.query.SELECT.limit.offset?.val ?? req.query.SELECT.limit.offset > 0) return false
  if (req.query.SELECT.orderBy?.some(o => !o.ref)) return false
  return (
    !req.query.SELECT.columns ||
    req.query.SELECT.columns.some(c => c === '*' || c.ref?.[0] === '*') ||
    req.query.SELECT.orderBy?.every(o => req.query.SELECT.columns?.some(c => o.ref[0] === c.ref?.[0]))
  )
}

const _checkExpandDeep = (column, entity, namespace) => {
  const { expand } = column
  if (expand.length > 1 || expand[0] !== '*') {
    for (const expandColumn of expand) {
      if (expandColumn === '*') continue
      if (expandColumn.expand) {
        _checkExpandDeep(expandColumn, entity.elements[expandColumn.ref[0]]._target, namespace)
      }
    }
  }
  if (!entity.name.startsWith(namespace) && !entity._service) {
    // proxy, only add keys
    const asteriskIndex = column.expand.findIndex(e => e === '*')
    column.expand.splice(asteriskIndex)
    for (const key in entity.keys) {
      if (entity.elements[key].isAssociation) continue
      column.expand.push({ ref: [key] })
    }
  }
}

const resolveProxyExpands = ({ SELECT: { columns }, target: entity }, service) => {
  if (!columns) return

  for (const column of columns) {
    if (column.expand) {
      _checkExpandDeep(column, entity.elements[column.ref[0]]._target, service.namespace)
    }
  }
}

const _isNullableSingleton = query => query._target._isSingleton && query._target['@odata.singleton.nullable']

const _isToOneAssoc = query =>
  query.SELECT.from.ref.length > 1 && typeof query.SELECT.from.ref.slice(-1)[0] === 'string'

const _count = result => {
  return Array.isArray(result)
    ? result.reduce((acc, val) => {
        return acc + (val?.$count ?? val?._counted_ ?? (Array.isArray(val) && _count(val))) || 0
      }, 0)
    : (result.$count ?? result._counted_ ?? 0)
}

// basically stolen from old read handler without understanding it ^^
const _handleArrayOfQueries = (srv, req, res, next) => {
  const info = metaInfo(req._query, 'READ', srv, {}, req, false)
  const cdsReq = new cds.Request({ query: req._query, req, res })
  srv
    .dispatch(cdsReq)
    .then(result => {
      handleSapMessages(cdsReq, req, res)

      if (req.url.match(/\/\$count/)) return res.set('content-type', 'text/plain').send(_count(result).toString())

      for (let i = 0; i < result.length; i++) {
        // Add OData context, if it deviates from main context
        if (i !== 0 && info.metadata.contextUrl !== info.metadata.additionalContextUrl[i - 1])
          result[i].forEach(entry => (entry['@odata.context'] = info.metadata.additionalContextUrl[i - 1]))
      }

      res.set('content-type', 'application/json;IEEE754Compatible=true')
      const flatRes = result.flat(Infinity)
      if (cdsReq.query[0].SELECT.count) flatRes.$count = flatRes.length
      res.send(toODataResult(flatRes, info))
    })
    .catch(next)
}

module.exports = srv =>
  function read(req, res, next) {
    if (getPreferReturnHeader(req)) {
      const msg = `The 'return' preference is not allowed in ${req.method} requests`
      throw Object.assign(new Error(msg), { statusCode: 400 })
    }

    // $apply with concat -> multiple queries with special handling
    if (Array.isArray(req._query)) return _handleArrayOfQueries(srv, req, res, next)

    // REVISIT: better solution for _propertyAccess
    let {
      SELECT: { from },
      target,
      _propertyAccess
    } = req._query
    const { _query: query } = req

    // payload & params
    const { keys, params } = getKeysAndParamsFromPath(from, srv)
    const data = keys //> for read and delete, we provide keys in req.data

    // cdsReq.headers should contain merged headers of envelope and subreq
    const headers = { ...cds.context.http.req.headers, ...req.headers }

    // we need a cds.Request for multiple reasons, incl. params, headers, sap-messages, read after write, ...
    const cdsReq = new cds.Request({ query, data, params, headers, req, res })
    Object.defineProperty(cdsReq, 'protocol', { value: 'odata-v4' })

    // API for subrequests of $batch (or incoming request)
    cdsReq.req = req
    cdsReq.res = res

    // REVISIT: what is this for? some tests fail without it... we should find a better solution!
    Object.defineProperty(query.SELECT, '_4odata', { value: true })

    // do now to get meta info before the query is rewritten + to know return type
    const info = metaInfo(query, 'READ', srv, {}, req, false)

    // FIXME: wrong contextUrl for SiblingEntity
    if (info.metadata.contextUrl.match(/\/SiblingEntity\//)) {
      const split = info.metadata.contextUrl.split('/')
      const i = split.findIndex(s => s === 'SiblingEntity')
      split.splice(i, 1)
      if (split[i - 1].match(/IsActiveEntity=false/)) {
        split[i - 1] = split[i - 1].replace('IsActiveEntity=false', 'IsActiveEntity=true')
        info.metadata.contextUrl = split.join('/')
      } else {
        info.metadata.contextUrl = split.join('/').replace(/IsActiveEntity=true/g, 'IsActiveEntity=false')
      }
    }

    const lastPathElement = req.path.split('/').slice(-1)[0]

    if (cds.env.effective.odata.proxies && cds.env.effective.odata.xrefs) {
      // REVISIT check above is still not perfect solution
      resolveProxyExpands(query, srv)
    }

    handleStreamProperties(target, query.SELECT.columns, srv.model)

    // REVISIT: what is this for? some tests fail without it... we should find a better solution!
    Object.defineProperty(query.SELECT, '_4odata', { value: true })

    return srv
      .dispatch(cdsReq)
      .then(result => {
        handleSapMessages(cdsReq, req, res)

        if (result == null) {
          if (!query.SELECT.one) {
            result = []
            if (req.query.$count) result.$count = 0
          } else if (_isNullableSingleton(query) || _isToOneAssoc(query)) {
            return res.sendStatus(204)
          } else {
            throw Object.assign(new Error('404'), { statusCode: 404 })
          }
        }

        if (validateIfNoneMatch(cdsReq, req, result)) {
          return res.status(304).end()
        }

        // express always handles if-none-match header (see req.fresh)
        if (!cdsReq.target._etag && req.headers['if-none-match']) {
          delete req.headers['if-none-match']
        }

        if (_propertyAccess && result[_propertyAccess] === null) return res.sendStatus(204)

        if (lastPathElement === '$count') {
          result = _getCount(result)
          return res.set('content-type', 'text/plain').send(result.toString())
        }

        if (lastPathElement === '$value' && _propertyAccess) {
          return res.set('content-type', 'text/plain').send(result[_propertyAccess].toString())
        }

        if (info.metadata.isCollection) _calculateNextLink(cdsReq, result)
        postProcess(cdsReq.target, srv, result)
        if (result['$etag']) res.set('etag', result['$etag'])
        result = toODataResult(result, info)

        // Express interprets numbers as HTTP status codes
        const isNumber = typeof result === 'number'
        res.set('content-type', isNumber ? 'text/plain' : 'application/json;IEEE754Compatible=true')
        res.send(isNumber ? result.toString() : result)
      })
      .catch(err => {
        handleSapMessages(cdsReq, req, res)
        next(err)
      })
  }
