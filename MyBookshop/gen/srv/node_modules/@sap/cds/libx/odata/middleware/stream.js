const cds = require('../../../')
const { Readable } = require('node:stream')
const getError = require('../../_runtime/common/error')
const { getTransition } = require('../../_runtime/common/utils/resolveView')
const LOG = cds.log('odata')
const { getKeysAndParamsFromPath, handleSapMessages, validateIfNoneMatch } = require('../utils')

const _resolveContentProperty = (target, annotName, resolvedProp) => {
  if (target.elements[resolvedProp]) {
    return resolvedProp
  }
  LOG._warn &&
    LOG.warn(
      `"${annotName}" in entity "${target.name}" points to property "${resolvedProp}" which was renamed or is not part of the projection. You must update the annotation value.`
    )
  const mapping = getTransition(target, cds.db).mapping
  const key = [...mapping.entries()].find(({ 1: val }) => val.ref[0] === resolvedProp)
  return key?.length && key[0]
}

const isStream = query => {
  const { _propertyAccess, target } = query
  if (!_propertyAccess) return

  const element = target.elements[_propertyAccess]
  return element._type === 'cds.LargeBinary' && element['@Core.MediaType']
}

const isStreamByDollarValue = (query, previous, last) => {
  return query.SELECT?.one && last === '$value' && !(previous in query.target.elements)
}

const _addMetadataProperty = (query, property, annotName, odataName) => {
  if (typeof property[annotName] === 'object') {
    const contentProperty = _resolveContentProperty(
      query.target,
      annotName,
      property[annotName]['='].replaceAll(/\./g, '_')
    )
    query.target.elements[contentProperty]
      ? query.SELECT.columns.push({ ref: [contentProperty], as: odataName })
      : LOG._warn &&
        LOG.warn(`"${annotName.split('.')[1]}" ${contentProperty} not found in entity "${query.target.name}".`)
  } else {
    query.SELECT.columns.push({ val: property[annotName], as: odataName })
  }
}

const addStreamMetadata = query => {
  // new odata parser sets streaming property in SELECT.from
  const ref = query.SELECT.columns?.[0].ref || query.SELECT.from.ref
  const propertyName = ref.at(-1)
  let mediaTypeProperty
  for (let key in query.target.elements) {
    const val = query.target.elements[key]
    if (val['@Core.MediaType'] && val.name === propertyName) {
      mediaTypeProperty = val
      break
    }
  }

  _addMetadataProperty(query, mediaTypeProperty, '@Core.MediaType', '$mediaContentType')

  if (mediaTypeProperty['@Core.ContentDisposition.Filename']) {
    _addMetadataProperty(
      query,
      mediaTypeProperty,
      '@Core.ContentDisposition.Filename',
      '$mediaContentDispositionFilename'
    )
  }

  if (mediaTypeProperty['@Core.ContentDisposition.Type']) {
    query.SELECT.columns.push({
      val: mediaTypeProperty['@Core.ContentDisposition.Type'],
      as: '$mediaContentDispositionType'
    })
  }
}

const validateStream = (req, result) => {
  // REVISIT: compat, should actually be treated as object
  if (!Array.isArray(result)) result = [result]

  // Reading one entity or a property of it should yield only a result length of one.
  if (result.length === 0 || result[0] === undefined) throw getError(404)

  if (result.length > 1) throw getError(400)

  if (result[0] === null) return

  result = result[0]

  const headers = req.headers
  const contentType = result.$mediaContentType

  if (!headers?.accept || !contentType) return

  if (
    !headers.accept.includes('*/*') &&
    !headers.accept.includes(contentType) &&
    !headers.accept.includes(contentType.split('/')[0] + '/*')
  ) {
    const msg = `Content type "${contentType}" is not listed in accept header "${headers.accept}"`
    throw Object.assign(new Error(msg), { statusCode: 406 })
  }
}

const _ensureStream = stream => {
  if (stream === null) return null
  // temp workaround for url streaming
  const stream_ = new Readable()
  stream_.push(stream)
  stream_.push(null)
  return stream_
}

const normalizeStream = (result, propertyName, lastPathElement, target) => {
  if (!result) return null

  let readable = result
  if (typeof result === 'object') {
    if (propertyName && result[propertyName] !== undefined) {
      readable = result[propertyName]
    }
    // implicit streaming
    else if (lastPathElement === '$value') {
      const property = Object.values(target.elements).find(
        el => el.type === 'cds.LargeBinary' && result[el.name] !== undefined
      )
      readable = property && result[property.name]
    }
    // result.value can be obtained from custom handlers
    else if (result.value !== undefined) {
      readable = result.value
    }
  }

  if (!(readable instanceof Readable)) {
    readable = _ensureStream(readable)
  }

  if (readable) {
    readable.on('error', () => {
      readable.removeAllListeners('error')
      // readable.destroy() does not end stream in node 10 and 12
      readable.push(null)
    })
  }

  return readable
}

const setStreamingHeaders = (result, res) => {
  // backwards compatibility for content-type in stream
  if (result['$mediaContentType']) res.setHeader('Content-Type', result.$mediaContentType)
  else if (result['*@odata.mediaContentType']) res.setHeader('Content-Type', result['*@odata.mediaContentType'])
  else res.setHeader('Content-Type', 'application/octet-stream')

  if ('$mediaContentDispositionFilename' in result) {
    const cdt = result.$mediaContentDispositionType || 'attachment'
    res.setHeader(
      'Content-Disposition',
      `${cdt}; filename="${encodeURIComponent(result.$mediaContentDispositionFilename)}"`
    )
  }
}

const stream = srv =>
  function streamHandler(req, res, next) {
    const { _query: query } = req

    // $apply with concat -> multiple queries with special handling -> read only, no stream?
    if (Array.isArray(query)) return next()

    const [previous, lastPathElement] = req.path.split('/').slice(-2)
    const _isStreamByDollarValue = isStreamByDollarValue(query, previous, lastPathElement)

    if (_isStreamByDollarValue) {
      for (const k in query.target.elements) {
        if (query.target.elements[k]['@Core.MediaType']) {
          query.SELECT.columns = [{ ref: [k] }]
          query._propertyAccess = k
          break
        }
      }
    }

    const pdfMimeType = !!req.headers.accept?.match(/application\/pdf/)
    const isMimeTypeStreamedByDefault = !!(!query.SELECT.one && pdfMimeType)
    const _isStream = isStream(query) || _isStreamByDollarValue || isMimeTypeStreamedByDefault

    if (!_isStream) return next()

    if (!query.target['@cds.persistence.skip'] && !isMimeTypeStreamedByDefault) {
      addStreamMetadata(query)
    }

    // we need the cds request, so we can access the modified query, which is cloned due to lean-draft, so we need to use dispatch here and pass a cds req
    const cdsReq = new cds.Request({ query, req, res })
    Object.defineProperty(cdsReq, 'protocol', { value: 'odata-v4' })

    // for read and delete, we provide keys in req.data
    // payload & params
    const { keys } = getKeysAndParamsFromPath(query.SELECT.from, srv)
    cdsReq.data = keys

    // REVISIT: what is this for? some tests fail without it... we should find a better solution!
    Object.defineProperty(query.SELECT, '_4odata', { value: true })

    return srv
      .tx(() => {
        return srv.dispatch(cdsReq).then(async result => {
          handleSapMessages(cdsReq, req, res)
          validateStream(req, result)

          if (validateIfNoneMatch(cdsReq, req, result)) {
            return res.status(304).end()
          }

          const stream = normalizeStream(result, query._propertyAccess, lastPathElement, query.target)
          if (stream === null) {
            res.status(204)
            return
          }

          if (pdfMimeType) {
            if (!result.$mediaContentType) result.$mediaContentType = 'application/pdf'
          }

          setStreamingHeaders(result, res)

          return new Promise((resolve, reject) => {
            if (res.destroyed) return reject(new Error('Response is closed while streaming'))
            stream.pipe(res)
            stream.on('end', () => resolve(result))
            stream.once('error', reject)
            let finished = false
            res.on('finish', () => {
              finished = true
            })
            res.on('close', () => !finished && reject(new Error('Response is closed while streaming')))
          })
        })
      })
      .then(() => {
        // we use an extra then block, after getting the result, so the transaction is commited, before sending the response
        res.end()
      })
      .catch(next) // catch outside of transaction, so tx is rolled back automatically in case of error
  }

module.exports = {
  stream,
  isStream
}
