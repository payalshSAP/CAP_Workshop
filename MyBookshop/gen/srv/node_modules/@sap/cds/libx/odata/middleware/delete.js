const cds = require('../../../')
const { UPDATE, DELETE } = cds.ql

const { getKeysAndParamsFromPath, handleSapMessages, getPreferReturnHeader } = require('../utils')

module.exports = srv =>
  function deleete(req, res, next) {
    if (getPreferReturnHeader(req)) {
      const msg = "The 'return' preference is not allowed in DELETE requests"
      throw Object.assign(new Error(msg), { statusCode: 400 })
    }

    // REVISIT: better solution for query._propertyAccess
    const {
      SELECT: { one, from },
      target,
      _propertyAccess
    } = req._query

    if (!one) {
      throw Object.assign(new Error('Method DELETE is not allowed for entity collections'), { statusCode: 405 })
    }

    // payload & params
    const { keys, params } = getKeysAndParamsFromPath(from, srv)
    const data = keys //> for read and delete, we provide keys in req.data
    if (_propertyAccess) data[_propertyAccess] = null //> delete of property -> set to null

    // query
    const query = _propertyAccess ? UPDATE(from).set({ [_propertyAccess]: null }) : DELETE.from(from)

    // cdsReq.headers should contain merged headers of envelope and subreq
    const headers = { ...cds.context.http.req.headers, ...req.headers }

    // we need a cds.Request for multiple reasons, incl. params, headers, sap-messages, read after write, ...
    const cdsReq = new cds.Request({ query, data, headers, params, req, res })
    Object.defineProperty(cdsReq, 'protocol', { value: 'odata-v4' })

    // API for subrequests of $batch (or incoming request)
    cdsReq.req = req
    cdsReq.res = res

    // rewrite event for draft-enabled entities
    if (target._isDraftEnabled && cdsReq.data.IsActiveEntity === false) cdsReq.event = 'CANCEL'

    return srv
      .dispatch(cdsReq)
      .then(() => {
        handleSapMessages(cdsReq, req, res)

        res.sendStatus(204)
      })
      .catch(err => {
        handleSapMessages(cdsReq, req, res)
        next(err)
      })
  }
