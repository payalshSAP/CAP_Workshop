const cds = require('../../../')
const LOG = cds.log('odata')

const crypto = require('crypto')

const _requestedFormat = (queryOption, header) => {
  if (queryOption) return queryOption.match(/json/i) ? 'json' : 'xml'
  if (header) {
    const jsonIndex = header.indexOf('application/json')
    if (jsonIndex === -1) return 'xml'
    const xmlIndex = header.indexOf('application/xml')
    if (xmlIndex === -1) return 'json'
    return jsonIndex < xmlIndex ? 'json' : 'xml'
  }
  return 'xml'
}

const _metadataFromFile = async srv => {
  const fs = require('fs')
  const filePath = cds.root + `/srv/odata/v4/${srv.name}.xml`
  let exists
  try {
    exists = !(await fs.promises.access(filePath, fs.constants.F_OK))
  } catch (e) {
    LOG._debug && LOG.debug(`No metadata file found for service ${srv.name} at ${filePath}`)
  }
  if (exists) {
    const file = await fs.promises.readFile(filePath)
    return file.toString()
  }
}

const normalize_header = value => {
  return value.split(',').map(str => str.trim())
}

const validate_etag = (header, etag) => {
  const normalized = normalize_header(header)
  return normalized.includes(etag) || normalized.includes('*') || normalized.includes('"*"')
}

const generateEtag = s => {
  return `W/"${crypto.createHash('sha256').update(s).digest('base64')}"`
}

const mpSupportsEmptyLocale = () => {
  const pkg = require(require.resolve('@sap/cds-mtxs/package.json'))
  const [major, minor] = pkg.version.split('.').map(Number)
  return major > 1 || (major === 1 && minor >= 12)
}

module.exports = srv =>
  async function metadata(req, res, _next) {
    if (req.method !== 'GET') {
      const msg = `Method ${req.method} is not allowed for calls to the metadata endpoint`
      throw Object.assign(new Error(msg), { statusCode: 405 })
    }

    const tenant = cds.context.tenant
    const locale = cds.context.locale
    const format = _requestedFormat(req.query['$format'], req.headers['accept'])

    // REVISIT: edm(x) and etag cache is only evicted with model
    const csnService = (cds.context.model || cds.model).definitions[srv.name]
    const metadataCache = (csnService.metadataCache = csnService.metadataCache || { jsonEtag: {}, xmlEtag: {} }) // REVISIT: yet another uncontrolled cache?

    const etag = format === 'json' ? metadataCache.jsonEtag?.[locale] : metadataCache.xmlEtag?.[locale]

    if (req.headers['if-match']) {
      if (etag) {
        const valid = validate_etag(req.headers['if-match'], etag)
        if (!valid) return res.status(412).end()
      }
    }

    if (req.headers['if-none-match']) {
      if (etag) {
        const unchanged = validate_etag(req.headers['if-none-match'], etag)
        if (unchanged) {
          res.set('etag', etag)
          return res.status(304).end()
        }
      }
    }

    const { 'cds.xt.ModelProviderService': mps } = cds.services
    if (mps) {
      if (format === 'json') {
        LOG._warn && LOG.warn('JSON metadata is not supported in case of cds.requires.extensibilty: true')
        const msg = 'JSON metadata is not supported for this service'
        throw Object.assign(new Error(msg), { statusCode: 501 })
      }

      try {
        let edmx
        // REVISIT: remove check later
        if (mpSupportsEmptyLocale()) {
          // If no extensibility nor fts, do not provide model to mtxs
          const modelNeeded = cds.env.requires.extensibility || cds.context.features?.given
          edmx =
            metadataCache.edm ||
            (await mps.getEdmx({ tenant, model: modelNeeded && srv.model, service: srv.definition.name }))
          metadataCache.edm = edmx
          const extBundle = cds.env.requires.extensibility && (await mps.getI18n({ tenant, locale }))
          edmx = cds.localize(srv.model, locale, edmx, extBundle)
        } else {
          edmx = await mps.getEdmx({ tenant, model: srv.model, service: srv.definition.name, locale })
        }
        metadataCache.xmlEtag[locale] = generateEtag(edmx)
        res.set('content-type', 'application/xml')
        res.send(edmx)
        return
      } catch (e) {
        if (LOG._error) {
          e.message = 'Unable to get EDMX for tenant ' + tenant + ' due to error: ' + e.message
          LOG.error(e)
        }
        throw Object.assign(new Error('503'), { statusCode: 503 })
      }
    }

    if (format === 'json') {
      const edm =
        metadataCache.edm || (metadataCache.edm = cds.compile.to.edm(srv.model, { service: srv.definition.name }))
      const localized = cds.localize(srv.model, locale, edm)
      metadataCache.jsonEtag[locale] = generateEtag(localized)
      return res.json(JSON.parse(localized))
    }

    const edmx =
      metadataCache.edmx ||
      (await _metadataFromFile(srv)) ||
      (metadataCache.edmx = cds.compile.to.edmx(srv.model, { service: srv.definition.name }))
    const localized = cds.localize(srv.model, locale, edmx)
    metadataCache.xmlEtag[locale] = generateEtag(localized)
    res.set('etag', metadataCache.xmlEtag[locale])
    res.set('content-type', 'application/xml')
    return res.send(localized)
  }
