const getTemplate = require('../../_runtime/common/utils/template')
const templateProcessor = require('../../_runtime/common/utils/templateProcessor')

const METADATA = {
  $context: '@odata.context',
  $count: '@odata.count',
  $etag: '@odata.etag',
  $metadataEtag: '@odata.metadataEtag',
  $bind: '@odata.bind',
  $id: '@odata.id',
  $delta: '@odata.delta',
  $removed: '@odata.removed',
  $type: '@odata.type',
  $nextLink: '@odata.nextLink',
  $deltaLink: '@odata.deltaLink',
  $editLink: '@odata.editLink',
  $readLink: '@odata.readLink',
  $navigationLink: '@odata.navigationLink',
  $associationLink: '@odata.associationLink',
  $mediaEditLink: '@odata.mediaEditLink',
  $mediaReadLink: '@odata.mediaReadLink',
  $mediaContentType: '@odata.mediaContentType',
  $mediaContentDispositionFilename: '@odata.mediaContentDispositionFilename', // > not supported by okra
  $mediaContentDispositionType: '@odata.mediaContentDispositionType', // > not supported by okra
  $mediaEtag: '@odata.mediaEtag'
}

const KEYSTOCLEANUP = {
  // do not set "@odata.context" as it may be inherited of remote service
  $context: true,
  // REVISIT: okra doesn't support content disposition
  $mediaContentDispositionFilename: true,
  $mediaContentDispositionType: true
}

const _metadataRoot = (result, odataResult) => {
  for (const key in METADATA) {
    if (!(key in result)) continue
    if (!KEYSTOCLEANUP[key]) odataResult[METADATA[key]] = result[key]
  }
}

const _metadata = (result, propertyName, odataResult) => {
  for (const key in result) {
    if (typeof result[key] === 'object') _metadata(result[key])
    if (!(key in METADATA)) continue
    if (!KEYSTOCLEANUP[key]) {
      if (propertyName) odataResult[METADATA[key]] = result[key]
      else result[METADATA[key]] = result[key]
    }
    if (!propertyName) delete result[key]
  }
}

const _cleanupMetadata = (propertyName, result) => {
  if (typeof result !== 'object') return odataResult

  const odataResult = {}
  if (propertyName) {
    odataResult.value = result[propertyName]
  } else {
    odataResult.value = result
  }

  if (Array.isArray(result)) _metadataRoot(result, odataResult)
  _metadata(result, propertyName, odataResult)

  return odataResult
}

const _setContext = (odataResult, info, isCollection) => {
  if (info && info.metadata) {
    const result = isCollection || info.metadata.propertyName ? odataResult : odataResult.value

    if (result != null) Object.assign(result, { [METADATA.$context]: info.metadata.contextUrl })
  }
  return odataResult
}

const _getParent = (model, name) => {
  const target = model.definitions[name]

  if (target && target.elements) {
    for (const elementName in target.elements) {
      const element = target.elements[elementName]
      if (element._anchor && element._anchor._isContained) return element._anchor
    }
  }

  return null
}

const addEtags = (row, key) => {
  if (!row[key]) return
  row['$etag'] = row[key].startsWith('W/') ? row[key] : `W/"${row[key]}"`
}

const _processCategory = (category, elementInfo) => {
  const { row, key } = elementInfo

  switch (category) {
    case '@odata.etag':
      addEtags(row, key)
      break
    case '@cds.api.ignore':
      delete row[key]
      break
    // no default
  }
}

const _processorFn = () => elementInfo => {
  const { row, key, plain } = elementInfo
  if (typeof row !== 'object' || !Object.prototype.hasOwnProperty.call(row, key)) return
  const categories = plain.categories

  for (const category of categories) {
    _processCategory(category, elementInfo)
  }
}

const _pick = element => {
  const categories = []
  if (element['@odata.etag']) categories.push('@odata.etag')
  if (element['@cds.api.ignore']) categories.push('@cds.api.ignore')
  if (categories.length) return { categories }
}

const postProcess = (target, service, result, isMinimal) => {
  const { model } = service
  if (!target || !result || !model || !model.definitions[target.name]) return

  const cacheKey = isMinimal ? 'postProcessMinimal' : 'postProcess'
  const parent = _getParent(model, target.name)
  const template = getTemplate(
    cacheKey,
    service,
    target,
    { pick: _pick, ignore: isMinimal ? el => el.isAssociation : undefined },
    parent
  )

  if (template.elements.size === 0) return

  // normalize result to rows
  result = result.value != null && Object.keys(result).filter(k => !k.match(/^\W/)).length === 1 ? result.value : result

  if (typeof result === 'object' && result != null) {
    const rows = Array.isArray(result) ? result : [result]

    // process each row
    const processFn = _processorFn()
    for (const row of rows) {
      templateProcessor({
        processFn,
        row,
        template
      })
    }
  }
}

/**
 * Convert any result to the result object structure, which is expected of odata-v4.
 *
 * @param {*} result
 * @param {*} [info]
 * @returns {string | object}
 */
const toODataResult = (result, info) => {
  if (result == null) return ''

  let propertyName, isCollection
  if (info) {
    propertyName = info.metadata.propertyName
    isCollection = info.metadata.isCollection
  }

  if (isCollection && !Array.isArray(result)) result = [result]
  else if (!isCollection && Array.isArray(result)) result = result[0]

  const odataResult = _cleanupMetadata(propertyName, result)

  // REVISIT: Support exponential decimals header
  // REVISIT: we always assume minimal metadata right now
  _setContext(odataResult, info, isCollection)

  if (!isCollection && !propertyName) return odataResult.value

  return odataResult
}

module.exports = { toODataResult, postProcess }
